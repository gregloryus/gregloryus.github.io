<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp v17</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font: 11px monospace; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 4px; }
        #controls { position: absolute; top: 10px; right: 10px; }
        #controls button { padding: 8px 14px; margin: 2px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 12px monospace; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div>Lava Lamp v17</div>
    <div id="stats"></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="rr">Reset</button>
</div>
<script>
// v17: Thermal expansion + contraction
// - Hot wax EXPANDS (spreads mass to neighbors, lowering density)
// - Cold wax CONTRACTS (absorbs mass from sparse neighbors, increasing density)
// - Buoyancy depends on density: below MEDIUM_DENSITY rises, above sinks
// - Contraction pulls thin columns together into rounder blobs
// - X-axis wraps (toroidal), Y-axis bounded

const CELL = 3;

// Thermal expansion model
const MEDIUM_DENSITY = 0.5;     // Density of the "liquid medium" - wax below this rises, above sinks
const MELT_THRESHOLD = 0.3;     // Temperature above which wax starts expanding
const EXPAND_RATE = 0.1;        // How fast hot wax expands into neighbors
const FREEZE_THRESHOLD = 0.25;  // Temperature below which wax starts contracting
const CONTRACT_RATE = 0.15;     // How fast cold wax contracts (pulls in neighbors)
const DENSITY_BUOYANCY = 0.8;   // How much density affects buoyancy
const HEAT_BUOYANCY = 0.3;      // How much temperature adds to buoyancy
const GRAVITY = 0.5;

// Heat transfer
const HEAT_IN = 0.005;
const HEAT_DIFF = 0.02;
const COOL = 0.01;

// Movement
const SURFACE_TENSION = 0.5;
const TENSION_RADIUS = 3;
const FLOW_RATE = 0.9;

// Heat zones
const CENTER_HEAT_MULT = 10;
const CENTER_HEAT_WIDTH = 0.1;
const INTENSITY_POWER = 2;

// Initial wax setup
const WAX_HEIGHT_FRAC = 0.1;
const WAX_GAP_WIDTH = 0;

let W, H, grid, frame = 0, paused = false, ff = 1;
let initialMass;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = Math.floor(canvas.width / CELL);
    H = Math.floor(canvas.height / CELL);
    reset();
}

function reset() {
    grid = new Float32Array(W * H * 2);
    const wH = Math.floor(H * WAX_HEIGHT_FRAC);
    const centerX = Math.floor(W / 2);
    const gapLeft = centerX - Math.floor(WAX_GAP_WIDTH / 2);
    const gapRight = centerX + Math.ceil(WAX_GAP_WIDTH / 2);
    for (let y = H - wH; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= gapLeft && x < gapRight) continue; // gap in center
            grid[(y * W + x) * 2] = 1;      // Start at full density (cold solid)
            grid[(y * W + x) * 2 + 1] = 0.1; // Start cool
        }
    }
    initialMass = getMass();
    frame = 0;
}

function getMass() {
    let m = 0;
    for (let i = 0; i < W * H; i++) m += grid[i * 2];
    return m;
}

// X-axis wraps, Y-axis bounded
function wrapX(x) { return ((x % W) + W) % W; }
function D(x, y) { return (y >= 0 && y < H) ? grid[(y * W + wrapX(x)) * 2] : 0; }
function T(x, y) { return (y >= 0 && y < H) ? grid[(y * W + wrapX(x)) * 2 + 1] : 0; }

function tick() {
    frame++;
    const next = new Float32Array(W * H * 2);
    for (let i = 0; i < next.length; i++) next[i] = grid[i];

    // Heat sources and sinks
    const bottomThird = Math.floor(H * 2 / 3);  // y >= this is bottom 1/3
    const topThird = Math.floor(H / 3);          // y < this is top 1/3
    // Center heat zone based on CENTER_HEAT_WIDTH
    const centerHeatLeft = Math.floor(W * (0.5 - CENTER_HEAT_WIDTH / 2));
    const centerHeatRight = Math.floor(W * (0.5 + CENTER_HEAT_WIDTH / 2));

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            if (next[i] < 0.01) continue;

            // HEATING: bottom 1/3, power curve (gentle at threshold, intense at bottom)
            if (y >= bottomThird) {
                const rowsFromBottom = H - 1 - y;
                const maxRowsInZone = H - bottomThird;
                const linearIntensity = (maxRowsInZone - rowsFromBottom) / maxRowsInZone;
                const verticalIntensity = Math.pow(linearIntensity, INTENSITY_POWER);

                // Horizontal: center portion gets CENTER_HEAT_MULT times more heat
                let horizMult = 1;
                if (x >= centerHeatLeft && x < centerHeatRight) {
                    horizMult = CENTER_HEAT_MULT;
                } else {
                    // Power curve falloff from center to edges
                    const distFromCenter = Math.abs(x - W/2);
                    const maxDist = W/2;
                    const linearHoriz = 1 - distFromCenter / maxDist;
                    horizMult = 1 + (CENTER_HEAT_MULT - 1) * Math.pow(linearHoriz, INTENSITY_POWER);
                }

                next[i + 1] = Math.min(1, next[i + 1] + HEAT_IN * verticalIntensity * horizMult);
            }

            // COOLING: top 1/3, power curve (gentle at threshold, intense at top)
            if (y < topThird) {
                const linearIntensity = (topThird - y) / topThird;
                const coolIntensity = Math.pow(linearIntensity, INTENSITY_POWER);
                next[i + 1] = Math.max(0, next[i + 1] - COOL * coolIntensity);
            }
        }
    }

    // Heat diffusion
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            const d = next[i];
            if (d < 0.01) continue;
            let sum = next[i + 1] * d, wt = d;
            for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const nd = D(x+dx, y+dy);
                if (nd > 0.01) { sum += T(x+dx, y+dy) * nd; wt += nd; }
            }
            next[i + 1] += ((sum / wt) - next[i + 1]) * HEAT_DIFF;
        }
    }

    // === THERMAL EXPANSION (discrete 0.5/0.5 split) ===
    // Hot wax at density ~1.0 splits into two 0.5 cells
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            const d = next[i];
            const t = next[i + 1];

            // Only split if: hot enough AND near full density
            if (t < MELT_THRESHOLD || d < 0.9) continue;

            // Probability of splitting based on temperature
            if (Math.random() > (t - MELT_THRESHOLD) * EXPAND_RATE * 10) continue;

            // Find an empty neighbor to split into (prefer upward)
            let bestNi = -1, bestSpace = 0;
            for (const [ox, oy] of [[0,-1],[-1,0],[1,0],[0,1]]) {  // Up first
                const ny = y + oy;
                if (ny < 0 || ny >= H) continue;
                const nx = wrapX(x + ox);
                const ni = (ny * W + nx) * 2;
                const nd = next[ni];
                const space = 1 - nd;
                if (space >= 0.5 && space > bestSpace) {
                    bestSpace = space;
                    bestNi = ni;
                }
            }

            if (bestNi >= 0) {
                // Split: this cell gives 0.5 to neighbor
                next[i] -= 0.5;
                next[bestNi] += 0.5;
                // Temperature follows
                const oldTargetD = next[bestNi] - 0.5;
                const oldTargetT = next[bestNi + 1];
                next[bestNi + 1] = (oldTargetT * oldTargetD + t * 0.5) / next[bestNi];
            }
        }
    }

    // === THERMAL CONTRACTION (discrete merge) ===
    // Cold wax at density ~0.5 merges with neighbor ~0.5 to form 1.0
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            const d = next[i];
            const t = next[i + 1];

            // Only merge if: cold enough AND at ~0.5 density
            if (t > FREEZE_THRESHOLD || d < 0.4 || d > 0.6) continue;

            // Probability of merging based on coldness
            if (Math.random() > (FREEZE_THRESHOLD - t) * CONTRACT_RATE * 10) continue;

            // Find a neighbor at ~0.5 density to merge with
            for (const [ox, oy] of [[0,1],[1,0],[-1,0],[0,-1]]) {  // Down first (cold sinks)
                const ny = y + oy;
                if (ny < 0 || ny >= H) continue;
                const nx = wrapX(x + ox);
                const ni = (ny * W + nx) * 2;
                const nd = next[ni];
                const nt = next[ni + 1];

                // Merge if neighbor is also ~0.5 density and cold
                if (nd >= 0.4 && nd <= 0.6 && nt < FREEZE_THRESHOLD) {
                    // Merge: absorb neighbor's mass
                    const totalMass = d + nd;
                    if (totalMass <= 1.0) {
                        next[i] = totalMass;
                        next[ni] = 0;
                        // Average temperature weighted by mass
                        next[i + 1] = (t * d + nt * nd) / totalMass;
                        next[ni + 1] = 0;
                        break;  // Only one merge per cell per tick
                    }
                }
            }
        }
    }

    // Calculate all transfers (mass-conserving)
    const transfers = [];

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const d = next[(y * W + x) * 2];
            if (d < 0.02) continue;
            const t = next[(y * W + x) * 2 + 1];

            // === GRAVITY + BUOYANCY (density-based) ===
            // Density below MEDIUM_DENSITY = buoyant (rises)
            // Density above MEDIUM_DENSITY = sinks
            // Temperature adds extra buoyancy
            const densityForce = (MEDIUM_DENSITY - d) * DENSITY_BUOYANCY;
            const heatForce = t * HEAT_BUOYANCY;
            const netForce = densityForce + heatForce - GRAVITY;
            const dy = netForce > 0 ? -1 : 1;
            const ty = y + dy;

            if (ty >= 0 && ty < H) {
                const targetD = next[(ty * W + x) * 2];
                const space = 1 - targetD;
                if (space > 0.01) {
                    const amount = Math.min(Math.abs(netForce) * FLOW_RATE, d * 0.4, space);
                    if (amount > 0.005) {
                        transfers.push({fx: x, fy: y, tx: x, ty: ty, amount, temp: t});
                    }
                }
            }

            // === SURFACE TENSION (expanded radius center-of-mass) ===
            // Calculate center of mass within TENSION_RADIUS, weighted by density and inverse distance
            let comX = 0, comY = 0, totalWeight = 0;
            let immediateNeighborD = 0;

            for (let oy = -TENSION_RADIUS; oy <= TENSION_RADIUS; oy++) {
                for (let ox = -TENSION_RADIUS; ox <= TENSION_RADIUS; ox++) {
                    if (ox === 0 && oy === 0) continue;
                    const ny = y + oy;
                    if (ny < 0 || ny >= H) continue;
                    const nx = wrapX(x + ox);

                    const nd = next[(ny * W + nx) * 2];
                    if (nd < 0.01) continue;

                    // Weight by density and inverse distance (closer = stronger pull)
                    const dist = Math.sqrt(ox * ox + oy * oy);
                    const weight = nd / dist;

                    comX += ox * weight;
                    comY += oy * weight;
                    totalWeight += weight;

                    // Track immediate neighbors for exposure calculation
                    if (Math.abs(ox) <= 1 && Math.abs(oy) <= 1 && (ox === 0 || oy === 0)) {
                        immediateNeighborD += nd;
                    }
                }
            }

            // If exposed (low immediate neighbor density) and there's a center of mass to pull toward
            if (immediateNeighborD < 3 && totalWeight > 0.1 && d > 0.2) {
                // Normalize to get direction
                comX /= totalWeight;
                comY /= totalWeight;

                // Move toward center of mass (one step at a time)
                const moveX = Math.abs(comX) > 0.3 ? Math.sign(comX) : 0;
                const moveY = Math.abs(comY) > 0.3 ? Math.sign(comY) : 0;

                if (moveX !== 0 || moveY !== 0) {
                    const sty = y + moveY;
                    if (sty >= 0 && sty < H) {
                        const stx = wrapX(x + moveX);
                        const targetD = next[(sty * W + stx) * 2];
                        const space = 1 - targetD;
                        const exposure = (4 - immediateNeighborD) / 4;
                        const pullStrength = Math.sqrt(comX * comX + comY * comY);
                        const amount = Math.min(SURFACE_TENSION * exposure * d * pullStrength, space, d * 0.3);
                        if (amount > 0.005) {
                            transfers.push({fx: x, fy: y, tx: stx, ty: sty, amount, temp: t});
                        }
                    }
                }
            }
        }
    }

    // Apply all transfers (mass-conserving)
    for (const tr of transfers) {
        const fi = (tr.fy * W + wrapX(tr.fx)) * 2;
        const ti = (tr.ty * W + wrapX(tr.tx)) * 2;

        const fromD = next[fi];
        const toD = next[ti];

        const actualAmount = Math.min(tr.amount, fromD - 0.01, 1 - toD);
        if (actualAmount < 0.005) continue;

        next[fi] -= actualAmount;
        next[ti] += actualAmount;

        const newToD = next[ti];
        if (newToD > 0.01) {
            const oldToD = toD;
            const oldToT = next[ti + 1];
            next[ti + 1] = (oldToT * oldToD + tr.temp * actualAmount) / newToD;
        }
    }

    // === BLOB ROUNDING (mass-conserving) ===
    for (let y = 1; y < H - 1; y++) {
        for (let x = 0; x < W; x++) {  // Full width for x-wrap
            const i = (y * W + x) * 2;
            const d = next[i];
            if (d < 0.3) continue;

            const xL = wrapX(x - 1), xR = wrapX(x + 1);
            const up = next[((y-1) * W + x) * 2];
            const dn = next[((y+1) * W + x) * 2];
            const lt = next[(y * W + xL) * 2];
            const rt = next[(y * W + xR) * 2];

            // Horizontal protrusion: spread left/right
            if (up > 0.5 && dn > 0.5 && lt < 0.2 && rt < 0.2) {
                const spaceL = 1 - lt, spaceR = 1 - rt;
                const wantSpread = d * 0.05;
                const actualL = Math.min(wantSpread, spaceL, d * 0.25);
                const actualR = Math.min(wantSpread, spaceR, d * 0.25 - actualL);
                if (actualL > 0.005 || actualR > 0.005) {
                    next[i] -= (actualL + actualR);
                    next[(y * W + xL) * 2] += actualL;
                    next[(y * W + xR) * 2] += actualR;
                }
            }

            // Vertical protrusion: spread up/down
            if (lt > 0.5 && rt > 0.5 && up < 0.2 && dn < 0.2) {
                const spaceU = 1 - up, spaceD = 1 - dn;
                const wantSpread = d * 0.05;
                const actualU = Math.min(wantSpread, spaceU, d * 0.25);
                const actualD = Math.min(wantSpread, spaceD, d * 0.25 - actualU);
                if (actualU > 0.005 || actualD > 0.005) {
                    next[i] -= (actualU + actualD);
                    next[((y-1) * W + x) * 2] += actualU;
                    next[((y+1) * W + x) * 2] += actualD;
                }
            }

            // Tip of protrusion: pull back toward the one neighbor
            const total = (up > 0.3 ? 1 : 0) + (dn > 0.3 ? 1 : 0) + (lt > 0.3 ? 1 : 0) + (rt > 0.3 ? 1 : 0);
            if (total === 1 && d > 0.3) {
                let targetIdx = -1, targetD = 0;
                if (up > 0.3) { targetIdx = ((y-1) * W + x) * 2; targetD = up; }
                else if (dn > 0.3) { targetIdx = ((y+1) * W + x) * 2; targetD = dn; }
                else if (lt > 0.3) { targetIdx = (y * W + xL) * 2; targetD = lt; }
                else if (rt > 0.3) { targetIdx = (y * W + xR) * 2; targetD = rt; }

                if (targetIdx >= 0) {
                    const space = 1 - targetD;
                    const pull = Math.min(d * 0.15, space, d - 0.01);
                    if (pull > 0.005) {
                        next[i] -= pull;
                        next[targetIdx] += pull;
                    }
                }
            }
        }
    }

    // Clamp values
    for (let i = 0; i < W * H; i++) {
        next[i * 2 + 1] = Math.max(0, Math.min(1, next[i * 2 + 1]));
        // Debug check - density should never exceed 1 or go negative
        if (next[i * 2] > 1.001 || next[i * 2] < -0.001) {
            console.warn('Density out of bounds:', next[i * 2], 'at', i);
        }
        next[i * 2] = Math.max(0, Math.min(1, next[i * 2]));
    }

    grid = next;
}

function render() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const d = grid[(y * W + x) * 2];
            if (d < 0.05) continue;
            const t = grid[(y * W + x) * 2 + 1];

            let r, g, b;
            if (t < 0.35) {
                r = 50 + 120 * (t / 0.35);
                g = 20 + 40 * (t / 0.35);
                b = 80 - 40 * (t / 0.35);
            } else if (t < 0.65) {
                const f = (t - 0.35) / 0.3;
                r = 170 + 60 * f;
                g = 60 + 80 * f;
                b = 40 - 20 * f;
            } else {
                const f = (t - 0.65) / 0.35;
                r = 230 + 25 * f;
                g = 140 + 115 * f;
                b = 20 + 100 * f;
            }

            ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${0.5 + d * 0.5})`;
            ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }
    }

    // Heater indicator (full width)
    ctx.fillStyle = 'rgba(255,80,0,0.6)';
    ctx.fillRect(0, (H-1) * CELL, W * CELL, 2);
}

function loop() {
    if (!paused) for (let i = 0; i < ff; i++) tick();
    render();

    const mass = getMass();
    document.getElementById('stats').innerHTML =
        `Tick: ${frame} | Mass: ${mass.toFixed(0)}/${initialMass.toFixed(0)} | FPS: 60`;

    requestAnimationFrame(loop);
}

document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 5 : ff === 5 ? 25 : ff === 25 ? 100 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? 'â–¶' : '||';
};
document.getElementById('rr').onclick = reset;
addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyR') reset();
});

resize();
loop();
</script>
</body>
</html>
