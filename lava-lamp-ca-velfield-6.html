<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp - Shan-Chen Hybrid v6</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font: 11px monospace; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; }
        #ui div { margin: 3px 0; }
        #ui label { display: inline-block; width: 130px; }
        #ui input { width: 60px; background: #333; color: #fff; border: 1px solid #555; padding: 2px 4px; }
        #controls { position: absolute; top: 10px; right: 10px; }
        #controls button { padding: 8px 14px; margin: 2px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 12px monospace; }
        .section { color: #888; margin-top: 8px; border-top: 1px solid #444; padding-top: 4px; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div><b>Shan-Chen Hybrid v6</b></div>
    <div style="color:#666;font-size:9px;">Clean physics: Force→Vel→Move</div>
    <div class="section">Grid</div>
    <div><label>Cell size</label><input type="number" id="cellSize" value="4" step="1"></div>
    <div class="section">Shan-Chen</div>
    <div><label>G (surface tension)</label><input type="number" id="G" value="-5.0" step="0.5"></div>
    <div class="section">Forces</div>
    <div><label>Buoyancy</label><input type="number" id="buoyancy" value="0.008" step="0.001"></div>
    <div><label>Gravity</label><input type="number" id="gravity" value="0.001" step="0.0005"></div>
    <div><label>Neutral temp</label><input type="number" id="neutralTemp" value="0.45" step="0.05"></div>
    <div class="section">Heat</div>
    <div><label>Heat rate</label><input type="number" id="heatRate" value="0.005" step="0.001"></div>
    <div><label>Cool rate</label><input type="number" id="coolRate" value="0.003" step="0.001"></div>
    <div><label>Diffusion</label><input type="number" id="tempDiffusion" value="0.08" step="0.01"></div>
    <div class="section">Velocity</div>
    <div><label>Damping</label><input type="number" id="velDamping" value="0.95" step="0.01"></div>
    <div id="stats" style="margin-top:8px;color:#aaa;font-size:10px;"></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="reset">Reset</button>
    <button id="view">WAX</button>
</div>

<script>
// ============================================
// SHAN-CHEN HYBRID v6 - Clean Physics
// ============================================
//
// Architecture:
// 1. Wax = discrete integers (0-8 units per cell), perfectly conserved
// 2. Forces from Shan-Chen pseudopotential (surface tension emerges)
// 3. Forces from thermal buoyancy (hot rises, cold sinks)
// 4. Classic physics: force → velocity, velocity → movement
// 5. Movement = discrete swaps in direction of velocity
//
// Key fix from v5: Check swaps in ALL 4 directions, not just down/right

let CELL_SIZE = 4;
const WAX_MAX = 8;
const INIT_WAX_HEIGHT = 0.15;

// D2Q9 lattice weights and directions for Shan-Chen
const W9 = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const CX = [0, 1, 0, -1, 0, 1, -1, -1, 1];
const CY = [0, 0, -1, 0, 1, -1, -1, 1, 1];

// Tunable parameters
const P = {
    cellSize: 4,
    G: -5.0,            // Shan-Chen interaction (negative = cohesion)
    buoyancy: 0.008,    // Thermal buoyancy
    gravity: 0.001,     // Base gravity (cold sinks)
    neutralTemp: 0.45,  // Neutral buoyancy temperature
    heatRate: 0.005,
    coolRate: 0.003,
    tempDiffusion: 0.08,
    velDamping: 0.95,   // Velocity persistence (like touch-boid-push)
};

let W, H;
let wax;      // Uint8: discrete wax units (0-8)
let temp;     // Float32: temperature
let velX, velY;  // Float32: velocity (accumulated from forces)

let frame = 0, paused = false, ff = 1, showVel = false;
let initialMass = 0;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    CELL_SIZE = P.cellSize;
    W = Math.floor(canvas.width / CELL_SIZE);
    H = Math.floor(canvas.height / CELL_SIZE);
    init();
}

function init() {
    const N = W * H;
    wax = new Uint8Array(N);
    temp = new Float32Array(N);
    velX = new Float32Array(N);
    velY = new Float32Array(N);

    // Initialize wax at bottom with wavy surface
    const waxTop = H - Math.floor(H * INIT_WAX_HEIGHT);
    initialMass = 0;

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            const surfaceNoise = Math.sin(x * 0.15) * 3 + Math.random() * 2;

            if (y >= waxTop + surfaceNoise) {
                wax[i] = WAX_MAX;
                temp[i] = 0.2 + Math.random() * 0.1;
                initialMass += WAX_MAX;
            }
        }
    }
    frame = 0;
}

// Shan-Chen pseudopotential: ψ(ρ) = 1 - e^(-ρ)
function psi(density) {
    return 1 - Math.exp(-density);
}

function tick() {
    frame++;
    const N = W * H;

    // === STEP 1: Compute smoothed density field ===
    // This gives gradients for Shan-Chen to work with
    const density = new Float32Array(N);
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            let sum = 0, count = 0;

            // 3x3 average
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                        sum += wax[ny * W + nx] / WAX_MAX;
                        count++;
                    }
                }
            }
            density[i] = sum / count;
        }
    }

    // === STEP 2: Compute forces ===
    const forceX = new Float32Array(N);
    const forceY = new Float32Array(N);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;

            if (wax[i] === 0) continue;

            const psi_i = psi(density[i]);

            // Shan-Chen force: F = -G * ψ_i * Σ(w_k * ψ_neighbor * e_k)
            let fx = 0, fy = 0;
            for (let k = 1; k < 9; k++) {
                const nx = x + CX[k], ny = y + CY[k];
                if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;

                const psi_n = psi(density[ny * W + nx]);
                fx += W9[k] * psi_n * CX[k];
                fy += W9[k] * psi_n * CY[k];
            }

            forceX[i] = -P.G * psi_i * fx;
            forceY[i] = -P.G * psi_i * fy;

            // Thermal buoyancy: hot rises (negative Y), cold sinks
            const t = temp[i];
            const buoyancyForce = -P.buoyancy * (t - P.neutralTemp);
            forceY[i] += buoyancyForce;

            // Gravity: always pulls down
            forceY[i] += P.gravity;
        }
    }

    // === STEP 3: Update velocity (force → velocity) ===
    // Classic physics from touch-boid-push: vel += force, vel *= damping
    for (let i = 0; i < N; i++) {
        if (wax[i] > 0) {
            velX[i] += forceX[i];
            velY[i] += forceY[i];
            velX[i] *= P.velDamping;
            velY[i] *= P.velDamping;
        } else {
            velX[i] = 0;
            velY[i] = 0;
        }
    }

    // === STEP 4: Update temperature ===
    const newTemp = new Float32Array(N);
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            if (wax[i] === 0) { newTemp[i] = 0; continue; }

            let t = temp[i];

            // Diffusion with wax neighbors
            let sum = t, count = 1;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                        const ni = ny * W + nx;
                        if (wax[ni] > 0) {
                            sum += temp[ni];
                            count++;
                        }
                    }
                }
            }
            t += (sum / count - t) * P.tempDiffusion;

            // Bottom heating
            if (y > H * 0.85) {
                const vertIntensity = (y - H * 0.85) / (H * 0.15);
                const horizIntensity = 1 - Math.abs(x / W - 0.5) * 1.5;
                if (horizIntensity > 0) {
                    t += P.heatRate * vertIntensity * horizIntensity;
                }
            }

            // Top cooling
            if (y < H * 0.15) {
                const intensity = 1 - y / (H * 0.15);
                t -= P.coolRate * intensity;
            }

            // No cap - let temp go beyond 0-1 for stronger dynamics
            newTemp[i] = Math.max(0, t);
        }
    }
    temp = newTemp;

    // === STEP 5: Movement via discrete swaps ===
    // KEY FIX: Check ALL 4 directions (up, down, left, right)
    // Use checkerboard pattern for conflict-free parallel updates

    const directions = [
        {dx: 0, dy: -1},  // UP
        {dx: 0, dy: 1},   // DOWN
        {dx: -1, dy: 0},  // LEFT
        {dx: 1, dy: 0},   // RIGHT
    ];

    for (const dir of directions) {
        // Two passes per direction for checkerboard
        for (let phase = 0; phase < 2; phase++) {
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    // Checkerboard: only process if (x + y) % 2 == phase
                    if ((x + y) % 2 !== phase) continue;

                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;

                    const i1 = y * W + x;
                    const i2 = ny * W + nx;

                    // Skip if both empty or both full (no point swapping)
                    if (wax[i1] === wax[i2]) continue;

                    // Compute desire to swap based on velocity projection
                    let desire = 0;

                    // Cell 1 wants to move in dir direction?
                    if (wax[i1] > 0) {
                        const proj = velX[i1] * dir.dx + velY[i1] * dir.dy;
                        if (proj > 0) desire += proj;
                    }

                    // Cell 2 wants to move in opposite direction?
                    if (wax[i2] > 0) {
                        const proj = velX[i2] * (-dir.dx) + velY[i2] * (-dir.dy);
                        if (proj > 0) desire += proj;
                    }

                    // Probabilistic swap
                    if (desire > 0.001) {
                        const chance = Math.min(1, desire * 2);
                        if (Math.random() < chance) {
                            // Swap wax, temp, and velocity
                            [wax[i1], wax[i2]] = [wax[i2], wax[i1]];
                            [temp[i1], temp[i2]] = [temp[i2], temp[i1]];

                            // Dampen velocity on swap (energy loss)
                            const vx1 = velX[i1] * 0.9, vy1 = velY[i1] * 0.9;
                            const vx2 = velX[i2] * 0.9, vy2 = velY[i2] * 0.9;
                            velX[i1] = vx2; velY[i1] = vy2;
                            velX[i2] = vx1; velY[i2] = vy1;
                        }
                    }
                }
            }
        }
    }
}

function render() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const imgData = ctx.createImageData(W, H);
    const px = imgData.data;

    for (let i = 0; i < W * H; i++) {
        const pi = i * 4;

        if (showVel) {
            // Velocity view: green=up, red=down, blue=horizontal
            const vy = velY[i] * 500;
            const vx = velX[i] * 500;
            const hasWax = wax[i] > 0 ? 1 : 0.3;

            px[pi] = Math.min(255, Math.max(0, 128 + vy * 10)) * hasWax;     // Red = down
            px[pi+1] = Math.min(255, Math.max(0, 128 - vy * 10)) * hasWax;   // Green = up
            px[pi+2] = Math.min(255, Math.abs(vx) * 20) * hasWax;            // Blue = horizontal
            px[pi+3] = 255;
        } else if (wax[i] > 0) {
            const t = temp[i];
            const b = 0.6 + 0.4 * wax[i] / WAX_MAX;

            let r, g, bl;
            if (t < 0.33) {
                const f = t / 0.33;
                r = (60 + 100*f) * b;
                g = (20 + 40*f) * b;
                bl = (120 - 40*f) * b;
            } else if (t < 0.66) {
                const f = (t - 0.33) / 0.33;
                r = (160 + 70*f) * b;
                g = (60 + 80*f) * b;
                bl = (80 - 60*f) * b;
            } else {
                const f = (t - 0.66) / 0.34;
                r = (230 + 25*f) * b;
                g = (140 + 110*f) * b;
                bl = (20 + 80*f) * b;
            }
            px[pi] = r; px[pi+1] = g; px[pi+2] = bl; px[pi+3] = 255;
        } else {
            px[pi] = 10; px[pi+1] = 10; px[pi+2] = 18; px[pi+3] = 255;
        }
    }

    const tmp = document.createElement('canvas');
    tmp.width = W; tmp.height = H;
    tmp.getContext('2d').putImageData(imgData, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tmp, 0, 0, W * CELL_SIZE, H * CELL_SIZE);
}

function loop() {
    if (!paused) {
        for (let i = 0; i < ff; i++) tick();
    }
    render();

    // Stats
    let mass = 0, maxV = 0, avgTemp = 0, waxCount = 0;
    for (let i = 0; i < W * H; i++) {
        mass += wax[i];
        const v = Math.sqrt(velX[i]*velX[i] + velY[i]*velY[i]);
        if (v > maxV) maxV = v;
        if (wax[i] > 0) { avgTemp += temp[i]; waxCount++; }
    }
    avgTemp = waxCount > 0 ? avgTemp / waxCount : 0;

    document.getElementById('stats').innerHTML =
        `Frame: ${frame}<br>` +
        `Mass: ${mass}/${initialMass}<br>` +
        `Grid: ${W}×${H}<br>` +
        `MaxVel: ${maxV.toFixed(3)}<br>` +
        `AvgTemp: ${avgTemp.toFixed(2)}`;

    requestAnimationFrame(loop);
}

// UI
function bind(id, key, resize_=false) {
    const el = document.getElementById(id);
    el.value = P[key];
    el.onchange = () => {
        P[key] = parseFloat(el.value);
        if (resize_) resize();
    };
}
bind('cellSize', 'cellSize', true);
bind('G', 'G');
bind('buoyancy', 'buoyancy');
bind('gravity', 'gravity');
bind('neutralTemp', 'neutralTemp');
bind('heatRate', 'heatRate');
bind('coolRate', 'coolRate');
bind('tempDiffusion', 'tempDiffusion');
bind('velDamping', 'velDamping');

document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 5 : ff === 5 ? 20 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? '▶' : '||';
};
document.getElementById('reset').onclick = () => resize();
document.getElementById('view').onclick = () => {
    showVel = !showVel;
    document.getElementById('view').textContent = showVel ? 'VEL' : 'WAX';
};

addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyR') resize();
    if (e.code === 'KeyV') { showVel = !showVel; document.getElementById('view').textContent = showVel ? 'VEL' : 'WAX'; }
});

resize();
loop();
</script>
</body>
</html>
