<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp LBM v11 (WebGL)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; }
        #ui { position: absolute; top: 4px; left: 6px; color: #fff; font: 9px monospace; background: rgba(0,0,0,0.8); padding: 4px 6px; border-radius: 3px; }
        #controls { position: absolute; top: 4px; right: 6px; display: flex; gap: 2px; }
        #controls button { padding: 3px 8px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 9px monospace; }
        #params { position: absolute; top: 28px; left: 0; right: 0; color: #ccc; font: 7px monospace; background: rgba(0,0,0,0.9); padding: 4px 8px; display: flex; flex-wrap: wrap; gap: 2px 12px; align-items: center; }
        #params label { display: flex; align-items: center; gap: 3px; white-space: nowrap; }
        #params input[type="number"] { width: 45px; background: #222; color: #fff; border: 1px solid #444; padding: 1px 2px; font: 7px monospace; }
        #params .section { color: #666; font-weight: bold; margin-left: 6px; }
        #params .section:first-child { margin-left: 0; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div>Lava Lamp LBM v11 (Optimized)</div>
    <div id="stats"></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="rr">Reset</button>
    <button id="toggleParams">Params</button>
</div>
<div id="params">
    <span class="section">Shan-Chen</span>
    <label>G_AA<input type="number" id="p_gAA" step="0.5" value="-5.0"></label>
    <label>G_BB<input type="number" id="p_gBB" step="0.5" value="0"></label>
    <label>G_AB<input type="number" id="p_gAB" step="0.5" value="5.0"></label>
    <span class="section">Density</span>
    <label>Wax<input type="number" id="p_rhoWax" step="0.05" value="1.2"></label>
    <label>Water<input type="number" id="p_rhoWater" step="0.05" value="1.0"></label>
    <label>WaxH<input type="number" id="p_waxH" step="0.02" value="0.15"></label>
    <span class="section">Viscosity</span>
    <label>TauWaxC<input type="number" id="p_tauWaxC" step="0.1" value="1.4"></label>
    <label>TauWaxH<input type="number" id="p_tauWaxH" step="0.05" value="0.9"></label>
    <label>TauWater<input type="number" id="p_tauWater" step="0.05" value="1.0"></label>
    <label>TransT<input type="number" id="p_transT" step="0.05" value="0.5"></label>
    <label>Sharp<input type="number" id="p_sharp" step="1" value="15"></label>
    <span class="section">Forces</span>
    <label>Buoy<input type="number" id="p_buoy" step="0.001" value="0.012"></label>
    <label>Grav<input type="number" id="p_grav" step="0.0001" value="0.0003"></label>
    <label>BuoyT<input type="number" id="p_buoyT" step="0.05" value="0.5"></label>
    <label>BuoySharp<input type="number" id="p_buoySharp" step="1" value="20"></label>
    <span class="section">Temp</span>
    <label>Heat<input type="number" id="p_heatR" step="0.001" value="0.005"></label>
    <label>Cool<input type="number" id="p_coolR" step="0.001" value="0.004"></label>
    <label>Diff<input type="number" id="p_diffuse" step="0.01" value="0.02"></label>
    <label>WaxT0<input type="number" id="p_initWaxT" step="0.05" value="0.2"></label>
    <label>WaterT0<input type="number" id="p_initWaterT" step="0.05" value="0.35"></label>
    <span class="section">Zones</span>
    <label>HeatY<input type="number" id="p_heatZone" step="0.02" value="0.85"></label>
    <label>HeatHF<input type="number" id="p_heatFall" step="0.5" value="2"></label>
    <label>CoolY<input type="number" id="p_coolZone" step="0.02" value="0.25"></label>
    <span class="section">Other</span>
    <label>Cell<input type="number" id="p_cell" step="1" value="4"></label>
</div>
<script>
// Lava Lamp LBM v11
// Optimized version with bug fixes:
// - REMOVED ambient cooling (was killing blobs mid-rise)
// - REMOVED interface sharpening (was causing dithering)
// - PRE-ALLOCATED all arrays (no per-frame allocations)
// - FIXED color rendering (proper blending, not broken premult)
// - INCREASED buoyancy and cooling zone for full-height travel
// - Reused temp canvas for rendering

// D2Q9 lattice constants
const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
const cy = [0, 0, -1, 0, 1, -1, -1, 1, 1];
const w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];

// Neighbor offset pairs (pre-allocated)
const neighborDx = [-1, 1, 0, 0];
const neighborDy = [0, 0, -1, 1];

let P = {};

function readParams() {
    P = {
        CELL: parseFloat(document.getElementById('p_cell').value),
        G_AA: parseFloat(document.getElementById('p_gAA').value),
        G_BB: parseFloat(document.getElementById('p_gBB').value),
        G_AB: parseFloat(document.getElementById('p_gAB').value),
        RHO_WAX: parseFloat(document.getElementById('p_rhoWax').value),
        RHO_WATER: parseFloat(document.getElementById('p_rhoWater').value),
        WAX_HEIGHT_FRAC: parseFloat(document.getElementById('p_waxH').value),
        TAU_WAX_COLD: parseFloat(document.getElementById('p_tauWaxC').value),
        TAU_WAX_HOT: parseFloat(document.getElementById('p_tauWaxH').value),
        TAU_WATER: parseFloat(document.getElementById('p_tauWater').value),
        TRANSITION_TEMP: parseFloat(document.getElementById('p_transT').value),
        SHARPNESS: parseFloat(document.getElementById('p_sharp').value),
        THERMAL_BUOYANCY: parseFloat(document.getElementById('p_buoy').value),
        BASE_GRAVITY: parseFloat(document.getElementById('p_grav').value),
        BUOYANCY_THRESHOLD: parseFloat(document.getElementById('p_buoyT').value),
        BUOYANCY_SHARPNESS: parseFloat(document.getElementById('p_buoySharp').value),
        HEAT_RATE: parseFloat(document.getElementById('p_heatR').value),
        COOL_RATE: parseFloat(document.getElementById('p_coolR').value),
        TEMP_DIFFUSION: parseFloat(document.getElementById('p_diffuse').value),
        INIT_WAX_TEMP: parseFloat(document.getElementById('p_initWaxT').value),
        INIT_WATER_TEMP: parseFloat(document.getElementById('p_initWaterT').value),
        HEAT_ZONE_START: parseFloat(document.getElementById('p_heatZone').value),
        HEAT_HORIZ_FALLOFF: parseFloat(document.getElementById('p_heatFall').value),
        COOL_ZONE_END: parseFloat(document.getElementById('p_coolZone').value)
    };
}

let W, H, size;

// Pre-allocated arrays (set in reset)
let f_A, f_A_temp, f_B, f_B_temp;
let rho_A, rho_B, ux, uy, psi_A, psi_B, temp, newTemp;
let Fx_A, Fy_A, Fx_B, Fy_B;

let frame = 0, paused = false, ff = 1;
let initialMassA, initialMassB;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Reusable temp canvas for rendering
let tempCanvas, tempCtx;

function resize() {
    readParams();
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = Math.floor(canvas.width / P.CELL);
    H = Math.floor(canvas.height / P.CELL);
    size = W * H;

    // Create reusable temp canvas
    tempCanvas = document.createElement('canvas');
    tempCanvas.width = W;
    tempCanvas.height = H;
    tempCtx = tempCanvas.getContext('2d');

    reset();
}

function reset() {
    readParams();
    W = Math.floor(canvas.width / P.CELL);
    H = Math.floor(canvas.height / P.CELL);
    size = W * H;

    // Pre-allocate all arrays ONCE
    f_A = new Float32Array(size * 9);
    f_A_temp = new Float32Array(size * 9);
    f_B = new Float32Array(size * 9);
    f_B_temp = new Float32Array(size * 9);

    rho_A = new Float32Array(size);
    rho_B = new Float32Array(size);
    ux = new Float32Array(size);
    uy = new Float32Array(size);
    psi_A = new Float32Array(size);
    psi_B = new Float32Array(size);
    temp = new Float32Array(size);
    newTemp = new Float32Array(size);

    // Pre-allocate force arrays
    Fx_A = new Float32Array(size);
    Fy_A = new Float32Array(size);
    Fx_B = new Float32Array(size);
    Fy_B = new Float32Array(size);

    const waxTop = H - Math.floor(H * P.WAX_HEIGHT_FRAC);
    const interfaceWidth = 3;

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;

            const distFromInterface = y - waxTop;
            const blend = 0.5 * (1 + Math.tanh(distFromInterface / interfaceWidth));

            // Small noise at init only
            const noise = (Math.random() - 0.5) * 0.02;

            rho_A[i] = blend * P.RHO_WAX * (1 + noise);
            rho_B[i] = (1 - blend) * P.RHO_WATER * (1 + noise);
            temp[i] = blend * P.INIT_WAX_TEMP + (1 - blend) * P.INIT_WATER_TEMP;

            initEquilibrium(f_A, i, rho_A[i], 0, 0);
            initEquilibrium(f_B, i, rho_B[i], 0, 0);
        }
    }

    const masses = getTotalMass();
    initialMassA = masses.wax;
    initialMassB = masses.water;
    frame = 0;
}

function initEquilibrium(f, i, rho0, vx, vy) {
    const usq = vx * vx + vy * vy;
    const i9 = i * 9;
    for (let k = 0; k < 9; k++) {
        const cu = cx[k] * vx + cy[k] * vy;
        f[i9 + k] = w[k] * rho0 * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);
    }
}

function getTotalMass() {
    let massA = 0, massB = 0;
    for (let i = 0; i < size; i++) {
        massA += rho_A[i];
        massB += rho_B[i];
    }
    return { wax: massA, water: massB };
}

// Inline psi computation for speed
function computePsi(rho_val) {
    return 1 - Math.exp(-rho_val);
}

// Fast sigmoid with bounds check
function sigmoid(x) {
    if (x > 15) return 1;
    if (x < -15) return 0;
    return 1 / (1 + Math.exp(-x));
}

function tick() {
    frame++;

    // ========================================
    // Step 1: Compute macroscopic quantities
    // ========================================
    for (let i = 0; i < size; i++) {
        const i9 = i * 9;
        let rA = 0, rB = 0;
        let pxA = 0, pyA = 0;
        let pxB = 0, pyB = 0;

        for (let k = 0; k < 9; k++) {
            const fA = f_A[i9 + k];
            const fB = f_B[i9 + k];
            rA += fA;
            rB += fB;
            pxA += fA * cx[k];
            pyA += fA * cy[k];
            pxB += fB * cx[k];
            pyB += fB * cy[k];
        }

        rho_A[i] = rA;
        rho_B[i] = rB;

        const rTotal = rA + rB;
        if (rTotal > 0.001) {
            ux[i] = (pxA + pxB) / rTotal;
            uy[i] = (pyA + pyB) / rTotal;
        } else {
            ux[i] = 0;
            uy[i] = 0;
        }

        psi_A[i] = rA > 0.001 ? computePsi(rA) : 0;
        psi_B[i] = rB > 0.001 ? computePsi(rB) : 0;
    }

    // ========================================
    // Step 2: Compute Shan-Chen forces
    // ========================================
    // Zero force arrays (reuse, don't reallocate)
    Fx_A.fill(0);
    Fy_A.fill(0);
    Fx_B.fill(0);
    Fy_B.fill(0);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            const t_i = temp[i];
            const rA = rho_A[i];
            const psiA = psi_A[i];
            const psiB = psi_B[i];

            let sumA_x = 0, sumA_y = 0;
            let sumB_x = 0, sumB_y = 0;

            for (let k = 1; k < 9; k++) {
                let nx = (x + cx[k] + W) % W;
                let ny = y + cy[k];
                if (ny < 0) ny = 0;
                else if (ny >= H) ny = H - 1;

                const ni = ny * W + nx;
                const wk = w[k];
                const cxk = cx[k];
                const cyk = cy[k];

                sumA_x += wk * psi_A[ni] * cxk;
                sumA_y += wk * psi_A[ni] * cyk;
                sumB_x += wk * psi_B[ni] * cxk;
                sumB_y += wk * psi_B[ni] * cyk;
            }

            // Temperature-dependent cohesion
            const cohesionReduction = sigmoid(P.SHARPNESS * (t_i - P.TRANSITION_TEMP));
            const effectiveG_AA = P.G_AA * (1 - 0.4 * cohesionReduction);

            // Shan-Chen forces
            Fx_A[i] = -psiA * (effectiveG_AA * sumA_x + P.G_AB * sumB_x);
            Fy_A[i] = -psiA * (effectiveG_AA * sumA_y + P.G_AB * sumB_y);

            Fx_B[i] = -psiB * (P.G_AB * sumA_x + P.G_BB * sumB_x);
            Fy_B[i] = -psiB * (P.G_AB * sumA_y + P.G_BB * sumB_y);

            // Gravity and threshold buoyancy
            if (rA > 0.1) {
                // Constant gravity
                Fy_A[i] += P.BASE_GRAVITY * rA;

                // Threshold-gated buoyancy - ONLY above threshold
                const buoyancyGate = sigmoid(P.BUOYANCY_SHARPNESS * (t_i - P.BUOYANCY_THRESHOLD));
                const excessTemp = Math.max(0, t_i - P.BUOYANCY_THRESHOLD);
                const liftForce = P.THERMAL_BUOYANCY * rA * buoyancyGate * (1 + excessTemp * 3);
                Fy_A[i] -= liftForce;
            }
        }
    }

    // ========================================
    // Step 3: Collision for wax
    // ========================================
    for (let i = 0; i < size; i++) {
        const rA = rho_A[i];
        if (rA < 0.01) continue;

        const t = temp[i];
        const softness = sigmoid(P.SHARPNESS * (t - P.TRANSITION_TEMP));
        const tauA = P.TAU_WAX_COLD * (1 - softness) + P.TAU_WAX_HOT * softness;
        const invTauA = 1 / tauA;
        const forceFactor = 1 - 0.5 * invTauA;

        let vx = ux[i] + Fx_A[i] / rA * 0.5;
        let vy = uy[i] + Fy_A[i] / rA * 0.5;

        // Velocity clamp
        const uMagSq = vx * vx + vy * vy;
        if (uMagSq > 0.01) {
            const scale = 0.1 / Math.sqrt(uMagSq);
            vx *= scale;
            vy *= scale;
        }

        const usq = vx * vx + vy * vy;
        const i9 = i * 9;

        for (let k = 0; k < 9; k++) {
            const cxk = cx[k], cyk = cy[k];
            const cu = cxk * vx + cyk * vy;
            const feq = w[k] * rA * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);

            const Fi = w[k] * forceFactor * (
                (3 * (cxk - vx) + 9 * cu * cxk) * Fx_A[i] +
                (3 * (cyk - vy) + 9 * cu * cyk) * Fy_A[i]
            );

            f_A[i9 + k] += -(f_A[i9 + k] - feq) * invTauA + Fi;
        }
    }

    // ========================================
    // Step 4: Collision for water
    // ========================================
    const invTauB = 1 / P.TAU_WATER;
    const forceFactorB = 1 - 0.5 * invTauB;

    for (let i = 0; i < size; i++) {
        const rB = rho_B[i];
        if (rB < 0.01) continue;

        let vx = ux[i] + Fx_B[i] / rB * 0.5;
        let vy = uy[i] + Fy_B[i] / rB * 0.5;

        const uMagSq = vx * vx + vy * vy;
        if (uMagSq > 0.01) {
            const scale = 0.1 / Math.sqrt(uMagSq);
            vx *= scale;
            vy *= scale;
        }

        const usq = vx * vx + vy * vy;
        const i9 = i * 9;

        for (let k = 0; k < 9; k++) {
            const cxk = cx[k], cyk = cy[k];
            const cu = cxk * vx + cyk * vy;
            const feq = w[k] * rB * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);

            const Fi = w[k] * forceFactorB * (
                (3 * (cxk - vx) + 9 * cu * cxk) * Fx_B[i] +
                (3 * (cyk - vy) + 9 * cu * cyk) * Fy_B[i]
            );

            f_B[i9 + k] += -(f_B[i9 + k] - feq) * invTauB + Fi;
        }
    }

    // ========================================
    // Step 5: Streaming for wax
    // ========================================
    f_A_temp.fill(0);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            const i9 = i * 9;

            for (let k = 0; k < 9; k++) {
                const nx = (x + cx[k] + W) % W;
                const ny = y + cy[k];

                if (ny < 0 || ny >= H) {
                    f_A_temp[i9 + opposite[k]] += f_A[i9 + k];
                } else {
                    const ni = ny * W + nx;
                    f_A_temp[ni * 9 + k] += f_A[i9 + k];
                }
            }
        }
    }
    [f_A, f_A_temp] = [f_A_temp, f_A];

    // ========================================
    // Step 6: Streaming for water
    // ========================================
    f_B_temp.fill(0);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            const i9 = i * 9;

            for (let k = 0; k < 9; k++) {
                const nx = (x + cx[k] + W) % W;
                const ny = y + cy[k];

                if (ny < 0 || ny >= H) {
                    f_B_temp[i9 + opposite[k]] += f_B[i9 + k];
                } else {
                    const ni = ny * W + nx;
                    f_B_temp[ni * 9 + k] += f_B[i9 + k];
                }
            }
        }
    }
    [f_B, f_B_temp] = [f_B_temp, f_B];

    // ========================================
    // Step 7: Temperature evolution
    // ========================================
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            let t = temp[i];
            const rA = rho_A[i];

            // Heat diffusion through wax only
            let sum = t, count = 1;
            for (let d = 0; d < 4; d++) {
                const nx = (x + neighborDx[d] + W) % W;
                const ny = y + neighborDy[d];
                if (ny >= 0 && ny < H) {
                    const ni = ny * W + nx;
                    const wt = Math.min(rho_A[i], rho_A[ni]) / P.RHO_WAX;
                    sum += temp[ni] * wt;
                    count += wt;
                }
            }
            t += (sum / count - t) * P.TEMP_DIFFUSION;

            // Bottom heating (only in heat zone, only wax)
            const bottomZone = H * P.HEAT_ZONE_START;
            if (y > bottomZone && rA > 0.05) {
                const vertInt = (y - bottomZone) / (H - bottomZone);
                const centerDist = Math.abs(x - W / 2) / (W / 2);
                const horizInt = Math.pow(1 - centerDist, P.HEAT_HORIZ_FALLOFF);
                t += P.HEAT_RATE * vertInt * horizInt;
            }

            // Top cooling ONLY (removed ambient cooling!)
            const topZone = H * P.COOL_ZONE_END;
            if (y < topZone && rA > 0.05) {
                const intensity = 1 - y / topZone;
                t -= P.COOL_RATE * intensity;
            }

            newTemp[i] = Math.max(0, Math.min(1, t));
        }
    }
    // Swap temp buffers
    [temp, newTemp] = [newTemp, temp];
}

function render() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const imageData = tempCtx.createImageData(W, H);
    const data = imageData.data;

    for (let i = 0; i < size; i++) {
        const pi = i * 4;
        const rA = rho_A[i];
        const rB = rho_B[i];
        const t = temp[i];

        // Background color (dark blue)
        let r = 10, g = 10, b = 20;

        if (rA > 0.02) {
            // Wax color based on temperature
            let wr, wg, wb;
            if (t < 0.35) {
                // Cold: purple
                const f = t / 0.35;
                wr = 60 + 90 * f;
                wg = 20 + 30 * f;
                wb = 120 - 40 * f;
            } else if (t < 0.6) {
                // Warm: orange
                const f = (t - 0.35) / 0.25;
                wr = 150 + 70 * f;
                wg = 50 + 80 * f;
                wb = 80 - 60 * f;
            } else {
                // Hot: yellow
                const f = (t - 0.6) / 0.4;
                wr = 220 + 35 * f;
                wg = 130 + 125 * f;
                wb = 20 + 60 * f;
            }

            // Blend wax color with background based on wax density
            const waxAlpha = Math.min(1, rA / P.RHO_WAX);
            r = r * (1 - waxAlpha) + wr * waxAlpha;
            g = g * (1 - waxAlpha) + wg * waxAlpha;
            b = b * (1 - waxAlpha) + wb * waxAlpha;
        }

        data[pi] = r;
        data[pi + 1] = g;
        data[pi + 2] = b;
        data[pi + 3] = 255;
    }

    tempCtx.putImageData(imageData, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tempCanvas, 0, 0, W * P.CELL, H * P.CELL);

    // Heater glow
    const gradient = ctx.createLinearGradient(0, canvas.height - 15, 0, canvas.height);
    gradient.addColorStop(0, 'rgba(255,60,0,0)');
    gradient.addColorStop(1, 'rgba(255,60,0,0.7)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, canvas.height - 15, canvas.width, 15);
}

function loop() {
    if (!paused) {
        for (let i = 0; i < ff; i++) tick();
    }
    render();

    const masses = getTotalMass();
    const massRatioA = (masses.wax / initialMassA * 100).toFixed(1);
    const massRatioB = (masses.water / initialMassB * 100).toFixed(1);

    let maxT = 0, minWaxY = H;
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            if (rho_A[i] > 0.3) {
                if (temp[i] > maxT) maxT = temp[i];
                if (y < minWaxY) minWaxY = y;
            }
        }
    }
    const highestPct = ((H - minWaxY) / H * 100).toFixed(0);

    document.getElementById('stats').innerHTML =
        `Tick: ${frame} | Wax: ${massRatioA}% | MaxT: ${maxT.toFixed(2)} | Height: ${highestPct}% | ${W}x${H}`;

    requestAnimationFrame(loop);
}

document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 10 : ff === 10 ? 100 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? '>' : '||';
};
document.getElementById('rr').onclick = reset;

let paramsVisible = true;
document.getElementById('toggleParams').onclick = () => {
    paramsVisible = !paramsVisible;
    document.getElementById('params').style.display = paramsVisible ? 'flex' : 'none';
};

document.getElementById('params').addEventListener('change', reset);

addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyR') reset();
});

resize();
loop();
</script>
</body>
</html>
