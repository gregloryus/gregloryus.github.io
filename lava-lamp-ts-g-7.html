<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp CA v5 (Density Field & Smooth Blobs)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        #controls { position: absolute; top: 10px; left: 10px; color: #888; font-family: monospace; background: rgba(0,0,0,0.8); padding: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="controls">
        Lava Lamp CA v5 (Density Gradient)<br>
        Scale: <span id="scale-display"></span>x<br>
        Status: <span id="status">Nucleating Blobs...</span>
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        #version 300 es
        in vec4 position;
        out vec2 uv;
        void main() {
            uv = position.xy * 0.5 + 0.5;
            gl_Position = position;
        }
    </script>

    <script id="fs-thermal" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        uniform sampler2D uState;
        uniform vec2 uRes;
        in vec2 uv;
        out vec4 fragColor;

        float getEffectiveTemp(vec4 d, float y) {
            // Water = Gradient, Wax = Stored Temp
            if (d.r < 0.1) return 1.0 - y; 
            return d.g;
        }

        void main() {
            vec4 data = texture(uState, uv);
            float phase = data.r; 
            float temp = data.g;

            // Water resets to gradient
            if (phase < 0.1) {
                fragColor = vec4(0.0, 1.0 - uv.y, 0.0, 1.0);
                return;
            }

            vec2 px = 1.0 / uRes;
            
            // Sample neighbors for diffusion
            float tN = getEffectiveTemp(texture(uState, uv + vec2(0.0, px.y)), uv.y + px.y);
            float tS = getEffectiveTemp(texture(uState, uv - vec2(0.0, px.y)), uv.y - px.y);
            float tE = getEffectiveTemp(texture(uState, uv + vec2(px.x, 0.0)), uv.y);
            float tW = getEffectiveTemp(texture(uState, uv - vec2(px.x, 0.0)), uv.y);

            float avg = (tN + tS + tE + tW) * 0.25;
            float newTemp = temp + (avg - temp) * 0.03; // Diffusion Rate

            // Thermal Boundary Conditions
            if (uv.y < 0.05) newTemp = mix(newTemp, 1.0, 0.1); // Hot Bottom
            if (uv.y > 0.95) newTemp = mix(newTemp, 0.0, 0.1); // Cold Top

            fragColor = vec4(phase, newTemp, 0.0, 1.0);
        }
    </script>

    <script id="fs-swap" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        uniform sampler2D uState;
        uniform vec2 uRes;
        uniform int uPass;
        uniform float uTime;
        in vec2 uv;
        out vec4 fragColor;

        // --- TUNING v5: SMOOTH BLOBS ---
        
        // 1. Cohesion: Wax moves towards higher wax density.
        // This eliminates the "checkerboard" artifacts.
        float K_COHESION = 1.5;
        
        // 2. Buoyancy: Strength of rising/falling.
        float K_BUOYANCY = 0.25; 
        
        // 3. Threshold: Temp at which wax becomes neutral buoyancy.
        // > 0.6 rises, < 0.6 sinks.
        float T_NEUTRAL = 0.6;   

        // Calculate "Density" (Number of Wax Neighbors)
        // 3x3 kernel summation (excluding self)
        float getDensity(vec2 pos, vec2 px) {
            float d = 0.0;
            // Loop 3x3
            for(float i=-1.0; i<=1.0; i++) {
                for(float j=-1.0; j<=1.0; j++) {
                    if(i==0.0 && j==0.0) continue; // Skip self
                    vec4 samp = texture(uState, pos + vec2(i,j)*px);
                    d += step(0.5, samp.r); // Add 1.0 if Wax
                }
            }
            return d; // Range 0.0 to 8.0
        }

        void main() {
            vec2 px = 1.0 / uRes;
            ivec2 coord = ivec2(gl_FragCoord.xy);
            
            // --- CHECKERBOARD PARTNER SELECTION ---
            ivec2 partner_offset = ivec2(0,0);
            if (uPass == 0) {
                if (coord.x % 2 == 0) partner_offset = ivec2(1, 0); else partner_offset = ivec2(-1, 0);
            } else if (uPass == 1) {
                if ((coord.x + 1) % 2 == 0) partner_offset = ivec2(1, 0); else partner_offset = ivec2(-1, 0);
            } else if (uPass == 2) {
                if (coord.y % 2 == 0) partner_offset = ivec2(0, 1); else partner_offset = ivec2(0, -1);
            } else {
                if ((coord.y + 1) % 2 == 0) partner_offset = ivec2(0, 1); else partner_offset = ivec2(0, -1);
            }

            ivec2 partner_coord = coord + partner_offset;
            
            // Bounds Check
            if (partner_coord.x < 0 || partner_coord.x >= int(uRes.x) ||
                partner_coord.y < 0 || partner_coord.y >= int(uRes.y)) {
                fragColor = texture(uState, uv);
                return;
            }

            // Fetch Data
            vec4 me = texture(uState, uv);
            vec2 partner_uv = uv + vec2(partner_offset) * px;
            vec4 partner = texture(uState, partner_uv);

            // Optimization: If identical phase, no swap needed (ignore temp diffs for swap physics)
            if (me.r == partner.r) {
                fragColor = me;
                return;
            }

            // --- THE DENSITY GRADIENT LOGIC ---
            
            // 1. Calculate Local Densities (Before Swap)
            float my_density = getDensity(uv, px);
            float partner_density = getDensity(partner_uv, px);
            
            // 2. Score the Swap
            // We want WAX to move to HIGHER DENSITY.
            // We want OIL to move to LOWER DENSITY (away from wax).
            
            float score = 0.0;
            
            // Cohesion Term:
            // If I am Wax, I want to go to partner if partner_density > my_density
            // If I am Oil, I don't care (or reverse).
            // Simplified: (Wax_A - Wax_B) * (Density_B - Density_A)
            score += (me.r - partner.r) * (partner_density - my_density) * K_COHESION;
            
            // Buoyancy Term:
            // Vertical movement only.
            float dy = float(partner_coord.y - coord.y); // +1 if moving Up
            
            if (dy != 0.0) {
                // If I am Wax, do I want to move vertically?
                // Lift = (Temp - Neutral). Positive = Up.
                if (me.r > 0.5) score += dy * (me.g - T_NEUTRAL) * K_BUOYANCY;
                
                // If Partner is Wax, does IT want to move vertically (swapping into me)?
                // Note the negative sign (Partner moving opposite to dy)
                if (partner.r > 0.5) score -= dy * (partner.g - T_NEUTRAL) * K_BUOYANCY;
            }

            // --- DETERMINISTIC DECISION ---
            // If the score is positive, the swap improves the system state. Do it.
            // No random noise. No popping.
            
            bool doSwap = (score > 0.0);

            if (doSwap) fragColor = partner;
            else        fragColor = me;
        }
    </script>

    <script id="fs-render" type="x-shader/x-fragment">
        #version 300 es
        precision highp float;
        uniform sampler2D uState;
        uniform vec2 uRes;
        in vec2 uv;
        out vec4 fragColor;

        void main() {
            vec2 px = 1.0 / uRes;
            
            // Blur kernel for smooth edges
            vec4 sum = vec4(0.0);
            float total = 0.0;
            
            // 5-tap Gaussian-ish
            sum += texture(uState, uv) * 0.4;
            sum += texture(uState, uv + vec2(px.x, 0.0)) * 0.15;
            sum += texture(uState, uv - vec2(px.x, 0.0)) * 0.15;
            sum += texture(uState, uv + vec2(0.0, px.y)) * 0.15;
            sum += texture(uState, uv - vec2(0.0, px.y)) * 0.15;
            
            float density = sum.r; // Smooth Wax
            float temp = sum.g;

            // Colors
            vec3 cBackground = vec3(0.05, 0.05, 0.08); 
            vec3 cWaxCold = vec3(0.4, 0.0, 0.1); 
            vec3 cWaxHot = vec3(1.0, 0.3, 0.0);
            
            vec3 cWax = mix(cWaxCold, cWaxHot, temp);
            
            // The "Goo" Threshold
            // Sharp cutoff at 0.5 density makes it look liquid
            float alpha = smoothstep(0.45, 0.55, density);
            
            vec3 color = mix(cBackground, cWax, alpha);
            
            // Glow
            if (alpha > 0.1) color += cWax * 0.2 * temp;

            fragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        const SCALE = 4; 

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) alert("WebGL 2.0 needed");
        if (!gl.getExtension('EXT_color_buffer_float')) alert('Need EXT_color_buffer_float');

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSrc, fsSrc) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            return prog;
        }

        const vsSrc = document.getElementById('vs').text.trim();
        const fsThermalSrc = document.getElementById('fs-thermal').text.trim();
        const fsSwapSrc = document.getElementById('fs-swap').text.trim();
        const fsRenderSrc = document.getElementById('fs-render').text.trim();

        const progThermal = createProgram(gl, vsSrc, fsThermalSrc);
        const progSwap = createProgram(gl, vsSrc, fsSwapSrc);
        const progRender = createProgram(gl, vsSrc, fsRenderSrc);

        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        let texA, texB, fbo;
        let simWidth, simHeight;

        function initSimulation() {
            simWidth = Math.ceil(window.innerWidth / SCALE);
            simHeight = Math.ceil(window.innerHeight / SCALE);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            document.getElementById('scale-display').innerText = SCALE;

            if (texA) gl.deleteTexture(texA);
            if (texB) gl.deleteTexture(texB);
            
            const makeTex = () => {
                const t = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, t);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, simWidth, simHeight, 0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return t;
            };

            texA = makeTex();
            texB = makeTex();

            // Initialize with large blob at bottom
            const data = new Float32Array(simWidth * simHeight * 4);
            for (let i = 0; i < simWidth * simHeight; i++) {
                const x = i % simWidth;
                const y = Math.floor(i / simWidth);
                let phase = 0.0;
                
                // Noise base
                let n = Math.sin(x * 0.03) + Math.cos(y * 0.03);
                
                // Bottom pool
                if (y < simHeight * 0.2 && n > 0.0) phase = 1.0;
                
                data[i*4 + 0] = phase;
                data[i*4 + 1] = 0.0; 
                data[i*4 + 3] = 1.0; 
            }
            gl.bindTexture(gl.TEXTURE_2D, texA);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, simWidth, simHeight, gl.RGBA, gl.FLOAT, data);

            if (!fbo) fbo = gl.createFramebuffer();
        }

        window.addEventListener('resize', initSimulation);
        initSimulation();

        function render() {
            gl.viewport(0, 0, simWidth, simHeight);

            // 1. THERMAL
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texB, 0);
            gl.useProgram(progThermal);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texA);
            gl.uniform1i(gl.getUniformLocation(progThermal, "uState"), 0);
            gl.uniform2f(gl.getUniformLocation(progThermal, "uRes"), simWidth, simHeight);
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            let temp = texA; texA = texB; texB = temp;

            // 2. KINETIC SWAPS (Density Driven)
            gl.useProgram(progSwap);
            gl.uniform2f(gl.getUniformLocation(progSwap, "uRes"), simWidth, simHeight);
            gl.uniform1f(gl.getUniformLocation(progSwap, "uTime"), performance.now() * 0.001);

            for (let p = 0; p < 4; p++) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texB, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texA);
                gl.uniform1i(gl.getUniformLocation(progSwap, "uState"), 0);
                gl.uniform1i(gl.getUniformLocation(progSwap, "uPass"), p);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                temp = texA; texA = texB; texB = temp;
            }

            // 3. RENDER
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(progRender);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texA);
            gl.uniform1i(gl.getUniformLocation(progRender, "uState"), 0);
            gl.uniform2f(gl.getUniformLocation(progRender, "uRes"), simWidth, simHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>