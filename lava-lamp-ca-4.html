<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp CA v4</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font: 10px monospace; background: rgba(0,0,0,0.85); padding: 8px; border-radius: 4px; max-height: 90vh; overflow-y: auto; }
        #ui div { margin: 2px 0; }
        #ui label { display: inline-block; width: 110px; }
        #ui input[type="range"] { width: 80px; vertical-align: middle; }
        #ui input[type="number"] { width: 50px; background: #333; color: #fff; border: 1px solid #555; }
        #ui .section { color: #888; margin-top: 8px; border-top: 1px solid #333; padding-top: 4px; }
        #controls { position: absolute; top: 10px; right: 10px; }
        #controls button { padding: 8px 14px; margin: 2px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 12px monospace; }
        #stats { position: absolute; bottom: 10px; left: 10px; color: #fff; font: 11px monospace; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 4px; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div><b>Lava Lamp CA v4</b> <button id="toggleParams" style="padding:2px 6px;font-size:9px;">Hide</button></div>
    <div class="section">Heat</div>
    <div><label>heatRate</label><input type="range" id="p_heatRate" min="0.001" max="0.05" step="0.001"><span id="v_heatRate"></span></div>
    <div><label>heatSpread</label><input type="range" id="p_heatSpread" min="0.01" max="0.3" step="0.01"><span id="v_heatSpread"></span></div>
    <div><label>coolRate</label><input type="range" id="p_coolRate" min="0.001" max="0.02" step="0.001"><span id="v_coolRate"></span></div>
    <div><label>heatSourceWidth</label><input type="range" id="p_heatSourceWidth" min="0.1" max="1.0" step="0.1"><span id="v_heatSourceWidth"></span></div>
    <div class="section">Movement</div>
    <div><label>buoyancyScale</label><input type="range" id="p_buoyancyScale" min="0.01" max="0.2" step="0.01"><span id="v_buoyancyScale"></span></div>
    <div><label>velocityDamping</label><input type="range" id="p_velocityDamping" min="0.7" max="0.99" step="0.01"><span id="v_velocityDamping"></span></div>
    <div><label>velocityThreshold</label><input type="range" id="p_velocityThreshold" min="0.05" max="0.5" step="0.01"><span id="v_velocityThreshold"></span></div>
    <div><label>moveChanceScale</label><input type="range" id="p_moveChanceScale" min="0.05" max="0.5" step="0.01"><span id="v_moveChanceScale"></span></div>
    <div class="section">Cohesion (Boids-style)</div>
    <div><label>alignment</label><input type="range" id="p_alignment" min="0.5" max="0.99" step="0.01"><span id="v_alignment"></span></div>
    <div><label>surfaceTension</label><input type="range" id="p_surfaceTension" min="0" max="0.2" step="0.01"><span id="v_surfaceTension"></span></div>
    <div><label>minDestNeighbors</label><input type="range" id="p_minDestNeighbors" min="0" max="4" step="1"><span id="v_minDestNeighbors"></span></div>
    <div class="section">Brownian</div>
    <div><label>brownianStrength</label><input type="range" id="p_brownianStrength" min="0" max="0.1" step="0.005"><span id="v_brownianStrength"></span></div>
    <div><label>horizontalBias</label><input type="range" id="p_horizontalBias" min="0" max="1" step="0.1"><span id="v_horizontalBias"></span></div>
    <div class="section">Concentration</div>
    <div><label>equalizationRate</label><input type="range" id="p_equalizationRate" min="0.1" max="0.8" step="0.05"><span id="v_equalizationRate"></span></div>
    <div><label>concentrationPull</label><input type="range" id="p_concentrationPull" min="0" max="0.5" step="0.02"><span id="v_concentrationPull"></span></div>
    <div class="section">Setup</div>
    <div><label>initialWaxHeight</label><input type="range" id="p_initialWaxHeight" min="0.05" max="0.3" step="0.01"><span id="v_initialWaxHeight"></span></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="heat">Heat ON</button>
</div>
<div id="stats"></div>
<script>
// ============================================
// LAVA LAMP CA v4 - Boids-inspired cohesion
// ============================================

const CELL = 4;

// All tunable parameters
const PARAMS = {
    // Heat
    heatRate: 0.02,
    heatSpread: 0.12,
    coolRate: 0.005,
    heatSourceWidth: 0.5,

    // Movement
    buoyancyScale: 0.08,
    velocityDamping: 0.88,
    velocityThreshold: 0.15,
    moveChanceScale: 0.15,

    // Cohesion (Boids-style alignment)
    alignment: 0.92,           // Very strong velocity alignment with neighbors
    surfaceTension: 0.1,
    minDestNeighbors: 2,

    // Brownian
    brownianStrength: 0.03,
    horizontalBias: 0.4,

    // Concentration
    equalizationRate: 0.4,
    concentrationPull: 0.15,   // NEW: extra force to close bubbles

    // Setup
    initialWaxHeight: 0.12,
};

let W, H;
let units, temp, velY, velX;
let unitsNext, tempNext, velYNext, velXNext;

let frame = 0, paused = false, ff = 1, heatOn = true;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Setup UI controls
function setupUI() {
    for (const key of Object.keys(PARAMS)) {
        const slider = document.getElementById('p_' + key);
        const display = document.getElementById('v_' + key);
        if (slider && display) {
            slider.value = PARAMS[key];
            display.textContent = PARAMS[key];
            slider.addEventListener('input', () => {
                PARAMS[key] = parseFloat(slider.value);
                display.textContent = PARAMS[key];
                reset(); // Reset sim on any param change
            });
        }
    }
}

function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = Math.floor(canvas.width / CELL);
    H = Math.floor(canvas.height / CELL);
    reset();
}

function reset() {
    const size = W * H;

    units = new Float32Array(size);
    temp = new Float32Array(size);
    velY = new Float32Array(size);
    velX = new Float32Array(size);

    unitsNext = new Float32Array(size);
    tempNext = new Float32Array(size);
    velYNext = new Float32Array(size);
    velXNext = new Float32Array(size);

    const waxTop = H - Math.floor(H * PARAMS.initialWaxHeight);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            if (y >= waxTop) {
                const surfaceNoise = Math.sin(x * 0.15) * 3 + Math.random() * 2;
                if (y >= waxTop + surfaceNoise) {
                    units[i] = 8.0;
                    temp[i] = 0.1 + Math.random() * 0.05;
                }
            }
            velY[i] = 0;
            velX[i] = 0;
        }
    }
    frame = 0;
}

function getCapacity(t) {
    if (t >= 0.66) return 6;
    if (t >= 0.33) return 7;
    return 8;
}

function idx(x, y) {
    x = Math.max(0, Math.min(W - 1, x));
    y = Math.max(0, Math.min(H - 1, y));
    return y * W + x;
}

function tick() {
    frame++;

    unitsNext.set(units);
    tempNext.set(temp);
    velYNext.set(velY);
    velXNext.set(velX);

    // === PHASE 1: Temperature Update ===
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            if (units[i] < 0.5) continue;

            let t = temp[i];

            // Heat source at bottom center
            if (heatOn && y >= H - 3) {
                const centerDist = Math.abs(x / W - 0.5);
                if (centerDist < PARAMS.heatSourceWidth * 0.5) {
                    const intensity = 1 - centerDist / (PARAMS.heatSourceWidth * 0.5);
                    t += PARAMS.heatRate * intensity;
                }
            }

            // Heat sink at top
            if (y <= 3) {
                t -= PARAMS.coolRate * 2;
            }

            // Heat equalization with wax neighbors
            let tempSum = 0, waxNeighbors = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const ni = idx(x + dx, y + dy);
                    if (units[ni] > 0.5) {
                        tempSum += temp[ni];
                        waxNeighbors++;
                    }
                }
            }

            if (waxNeighbors > 0) {
                const avgTemp = tempSum / waxNeighbors;
                t += (avgTemp - t) * PARAMS.heatSpread;
            }

            tempNext[i] = Math.max(0, Math.min(1, t));
        }
    }
    [temp, tempNext] = [tempNext, temp];

    // === PHASE 2: Equalization + Concentration ===
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            if (units[i] < 0.5) continue;

            const capacity = getCapacity(temp[i]);
            let u = units[i];

            // Count neighbors and find empty ones (for concentration pull)
            let emptyNeighborDir = null;
            let waxNeighborCount = 0;

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const ni = idx(x + dx, y + dy);
                    if (units[ni] > 0.5) {
                        waxNeighborCount++;
                        const nCapacity = getCapacity(temp[ni]);
                        const myRatio = u / capacity;
                        const nRatio = units[ni] / nCapacity;
                        const flow = (nRatio - myRatio) * PARAMS.equalizationRate * 0.125;
                        u += flow;
                    } else {
                        // Track empty neighbor for concentration pull
                        emptyNeighborDir = {dx, dy};
                    }
                }
            }

            // Pressure relief
            if (u > capacity) {
                let lowestRatio = 1, lowestIdx = -1;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const ni = idx(x + dx, y + dy);
                        if (units[ni] > 0.5) {
                            const nCapacity = getCapacity(temp[ni]);
                            const nRatio = units[ni] / nCapacity;
                            if (nRatio < lowestRatio && units[ni] < nCapacity) {
                                lowestRatio = nRatio;
                                lowestIdx = ni;
                            }
                        }
                    }
                }
                if (lowestIdx >= 0) {
                    const excess = u - capacity;
                    const transfer = excess * 0.3;
                    u -= transfer;
                    unitsNext[lowestIdx] += transfer;
                }
            }

            unitsNext[i] = Math.max(0, Math.min(8, u));
        }
    }
    [units, unitsNext] = [unitsNext, units];

    // === PHASE 3: Close bubbles - empty cells surrounded by wax get filled ===
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;

            if (units[i] < 0.5) {
                // I'm empty - count wax neighbors
                let waxNeighbors = 0;
                let totalUnitsAround = 0;
                let totalTemp = 0;

                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const ni = idx(x + dx, y + dy);
                        if (units[ni] > 0.5) {
                            waxNeighbors++;
                            totalUnitsAround += units[ni];
                            totalTemp += temp[ni];
                        }
                    }
                }

                // If surrounded by many wax cells, pull units in (close the bubble)
                if (waxNeighbors >= 5) {
                    const pullAmount = PARAMS.concentrationPull * waxNeighbors;
                    unitsNext[i] = pullAmount;
                    tempNext[i] = totalTemp / waxNeighbors;
                }
            } else {
                unitsNext[i] = units[i];
                tempNext[i] = temp[i];
            }
        }
    }
    [units, unitsNext] = [unitsNext, units];
    [temp, tempNext] = [tempNext, temp];

    // === PHASE 4: Buoyancy + Boids-style Alignment ===
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;

            if (units[i] < 0.5) {
                velYNext[i] = 0;
                velXNext[i] = 0;
                continue;
            }

            const capacity = getCapacity(temp[i]);

            // Buoyancy force
            const buoyancy = units[i] * (7 - capacity) * PARAMS.buoyancyScale;
            let vy = velY[i] - buoyancy;
            let vx = velX[i];

            // BOIDS-STYLE ALIGNMENT: Strong averaging with neighbors
            let vySum = 0, vxSum = 0, waxNeighbors = 0;
            let centerY = 0, centerX = 0;  // For cohesion toward center of mass

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const ni = idx(x + dx, y + dy);
                    if (units[ni] > 0.5) {
                        vySum += velY[ni];
                        vxSum += velX[ni];
                        centerY += dy;
                        centerX += dx;
                        waxNeighbors++;
                    }
                }
            }

            if (waxNeighbors > 0) {
                const avgVy = vySum / waxNeighbors;
                const avgVx = vxSum / waxNeighbors;

                // Strong alignment - blend heavily toward neighbor average
                vy = vy * (1 - PARAMS.alignment) + avgVy * PARAMS.alignment;
                vx = vx * (1 - PARAMS.alignment) + avgVx * PARAMS.alignment;

                // Slight pull toward center of mass of neighbors (cohesion)
                // If neighbors are mostly to one side, nudge velocity that way
                centerY /= waxNeighbors;
                centerX /= waxNeighbors;
                vy += centerY * 0.01;
                vx += centerX * 0.01;
            }

            // Damping
            vy *= PARAMS.velocityDamping;
            vx *= PARAMS.velocityDamping;

            // Brownian motion
            const noiseY = (Math.random() - 0.5) * 2 * PARAMS.brownianStrength * (1 - PARAMS.horizontalBias);
            const noiseX = (Math.random() - 0.5) * 2 * PARAMS.brownianStrength * (1 + PARAMS.horizontalBias);
            vy += noiseY;
            vx += noiseX;

            velYNext[i] = vy;
            velXNext[i] = vx;
        }
    }
    [velY, velYNext] = [velYNext, velY];
    [velX, velXNext] = [velXNext, velX];

    // === PHASE 5: Movement ===
    unitsNext.set(units);
    tempNext.set(temp);
    velYNext.set(velY);
    velXNext.set(velX);

    for (let parity = 0; parity < 2; parity++) {
        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                if ((x + y) % 2 !== parity) continue;

                const i = y * W + x;
                const u = units[i];
                if (u < 0.5) continue;

                const vy = velY[i];
                const vx = velX[i];

                // Count wax neighbors for surface tension
                let waxNeighbors = 0;
                for (let dy2 = -1; dy2 <= 1; dy2++) {
                    for (let dx2 = -1; dx2 <= 1; dx2++) {
                        if (dx2 === 0 && dy2 === 0) continue;
                        const ni = idx(x + dx2, y + dy2);
                        if (units[ni] > 0.5) waxNeighbors++;
                    }
                }

                const effectiveThreshold = PARAMS.velocityThreshold + waxNeighbors * PARAMS.surfaceTension;

                let targetX = x, targetY = y;

                // Probabilistic vertical movement
                const vyExcess = Math.abs(vy) - effectiveThreshold;
                if (vyExcess > 0) {
                    const moveChance = Math.min(1, vyExcess * PARAMS.moveChanceScale);
                    if (Math.random() < moveChance) {
                        if (vy < 0 && y > 0) targetY = y - 1;
                        else if (vy > 0 && y < H - 1) targetY = y + 1;
                    }
                }

                // Probabilistic horizontal movement
                const vxExcess = Math.abs(vx) - effectiveThreshold * 0.5;
                if (targetY === y && vxExcess > 0) {
                    const moveChance = Math.min(1, vxExcess * PARAMS.moveChanceScale);
                    if (Math.random() < moveChance) {
                        if (vx < 0 && x > 0) targetX = x - 1;
                        else if (vx > 0 && x < W - 1) targetX = x + 1;
                    }
                }

                const ti = targetY * W + targetX;

                if (ti !== i && unitsNext[ti] < 0.5) {
                    // Count destination's wax neighbors
                    let destWaxNeighbors = 0;
                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                            if (dx2 === 0 && dy2 === 0) continue;
                            const nx = targetX + dx2;
                            const ny = targetY + dy2;
                            if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
                            const ni = ny * W + nx;
                            if (ni !== i && units[ni] > 0.5) destWaxNeighbors++;
                        }
                    }

                    // Only move if destination keeps us connected
                    if (destWaxNeighbors >= PARAMS.minDestNeighbors) {
                        unitsNext[ti] = unitsNext[i];
                        tempNext[ti] = tempNext[i];
                        velYNext[ti] = velYNext[i] * 0.9;
                        velXNext[ti] = velXNext[i] * 0.9;

                        unitsNext[i] = 0;
                        tempNext[i] = 0;
                        velYNext[i] = 0;
                        velXNext[i] = 0;
                    }
                }
            }
        }

        [units, unitsNext] = [unitsNext, units];
        [temp, tempNext] = [tempNext, temp];
        [velY, velYNext] = [velYNext, velY];
        [velX, velXNext] = [velXNext, velX];

        unitsNext.set(units);
        tempNext.set(temp);
        velYNext.set(velY);
        velXNext.set(velX);
    }
}

function render() {
    const imageData = ctx.createImageData(W, H);
    const data = imageData.data;

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = y * W + x;
            const pi = i * 4;
            const u = units[i];
            const t = temp[i];

            if (u > 0.5) {
                let r, g, b;
                if (t < 0.33) {
                    const f = t / 0.33;
                    r = 60 + 100 * f;
                    g = 20 + 50 * f;
                    b = 120 - 40 * f;
                } else if (t < 0.66) {
                    const f = (t - 0.33) / 0.33;
                    r = 160 + 70 * f;
                    g = 70 + 70 * f;
                    b = 80 - 60 * f;
                } else {
                    const f = (t - 0.66) / 0.34;
                    r = 230 + 25 * f;
                    g = 140 + 100 * f;
                    b = 20 + 60 * f;
                }
                const brightness = 0.6 + (u / 8) * 0.4;
                data[pi] = Math.min(255, r * brightness);
                data[pi + 1] = Math.min(255, g * brightness);
                data[pi + 2] = Math.min(255, b * brightness);
                data[pi + 3] = 255;
            } else {
                data[pi] = 10;
                data[pi + 1] = 10;
                data[pi + 2] = 18;
                data[pi + 3] = 255;
            }
        }
    }

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = W;
    tempCanvas.height = H;
    tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);

    if (heatOn) {
        ctx.fillStyle = 'rgba(255, 80, 0, 0.5)';
        const heatWidth = canvas.width * PARAMS.heatSourceWidth;
        ctx.fillRect((canvas.width - heatWidth) / 2, canvas.height - 4, heatWidth, 4);
    }
}

function getTotalUnits() {
    let total = 0;
    for (let i = 0; i < W * H; i++) total += units[i];
    return total;
}

function loop() {
    if (!paused) {
        for (let i = 0; i < ff; i++) tick();
    }
    render();

    document.getElementById('stats').innerHTML =
        `Tick: ${frame} | Units: ${getTotalUnits().toFixed(0)} | Grid: ${W}x${H}`;

    requestAnimationFrame(loop);
}

// Controls
document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 10 : ff === 10 ? 100 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? 'â–¶' : '||';
};
document.getElementById('heat').onclick = () => {
    heatOn = !heatOn;
    document.getElementById('heat').textContent = heatOn ? 'Heat ON' : 'Heat OFF';
};

addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyH') { heatOn = !heatOn; document.getElementById('heat').textContent = heatOn ? 'Heat ON' : 'Heat OFF'; }
});

// Toggle params visibility
let paramsVisible = true;
document.getElementById('toggleParams').onclick = () => {
    paramsVisible = !paramsVisible;
    const allDivs = document.querySelectorAll('#ui > div:not(:first-child)');
    allDivs.forEach(el => el.style.display = paramsVisible ? '' : 'none');
    document.getElementById('toggleParams').textContent = paramsVisible ? 'Hide' : 'Show';
};

setupUI();
resize();
loop();
</script>
</body>
</html>
