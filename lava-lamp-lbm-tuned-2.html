<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp LBM v1 Tuned</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
            background: #0a0a12;
        }

        #canvas {
            display: block;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font: 11px monospace;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 4px;
            max-width: 300px;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        #controls button {
            padding: 8px 14px;
            margin: 2px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            cursor: pointer;
            font: 12px monospace;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div>Lava Lamp LBM v1 (Tuned)</div>
        <div>Optimized Thermal Model</div>
        <div id="stats"></div>
    </div>
    <div id="controls">
        <button id="ff">1x</button>
        <button id="pp">||</button>
        <button id="rr">Reset</button>
    </div>
    <script>
        // Lattice Boltzmann Method with Shan-Chen multi-phase
        // Tuned for better cycling behavior while keeping the "snap" of v1

        const CELL = 4;

        // D2Q9 lattice
        const cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const cy = [0, 0, -1, 0, 1, -1, -1, 1, 1];
        const w = [4 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 36, 1 / 36, 1 / 36, 1 / 36];
        const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];

        // Physics parameters - TUNED for "Thin Layer & Instability"
        const TAU = 0.6;               // Low viscosity
        const G_INTERACTION = -5.0;    // Standard snap
        const RHO_WAX = 2.0;
        const RHO_MEDIUM = 0.1;

        // Thermal Buoyancy - TUNED
        const THERMAL_BUOYANCY = 0.006;
        const BASE_GRAVITY = 0.0005;

        // Temperature parameters - TUNED
        const HEAT_RATE = 0.015;            // Stronger heat for thin layer
        const COOL_RATE = 0.003;
        const TEMP_DIFFUSION_WAX = 0.002;   // Low diffusion
        const TEMP_DIFFUSION_LEAK = 0.0001;
        const NEUTRAL_TEMP = 0.45;

        // Initial setup
        const WAX_HEIGHT_FRAC = 0.09;       // THIN LAYER (User suggestion)
        const HEATER_WIDTH_FRACTION = 6.0;  // Focused

        let W, H;
        let f, fTemp;
        let rho, ux, uy, temp, psi;
        let frame = 0, paused = false, ff = 1;
        let initialMass;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            W = Math.floor(canvas.width / CELL);
            H = Math.floor(canvas.height / CELL);
            reset();
        }

        function reset() {
            const size = W * H;
            f = new Float32Array(size * 9);
            fTemp = new Float32Array(size * 9);
            rho = new Float32Array(size);
            ux = new Float32Array(size);
            uy = new Float32Array(size);
            temp = new Float32Array(size);
            psi = new Float32Array(size);

            const waxTop = H - Math.floor(H * WAX_HEIGHT_FRAC);

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    if (y >= waxTop) {
                        // Add noise to break symmetry and prevent perfect arches
                        rho[i] = RHO_WAX + (Math.random() - 0.5) * 0.2;
                        temp[i] = 0.2; // Start cool
                    } else {
                        rho[i] = RHO_MEDIUM;
                        temp[i] = 0.2; // Ambient is cold
                    }
                    initEquilibrium(i, rho[i], 0, 0);
                }
            }
            initialMass = getTotalMass();
            frame = 0;
        }

        function initEquilibrium(i, rho0, ux0, uy0) {
            const usq = ux0 * ux0 + uy0 * uy0;
            for (let k = 0; k < 9; k++) {
                const cu = cx[k] * ux0 + cy[k] * uy0;
                f[i * 9 + k] = w[k] * rho0 * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);
            }
        }

        function getTotalMass() {
            let mass = 0;
            for (let i = 0; i < W * H; i++) {
                mass += rho[i];
            }
            return mass;
        }

        function computePsi(rho_val) {
            const rho0 = 1.0;
            return rho0 * (1 - Math.exp(-rho_val / rho0));
        }

        function tick() {
            frame++;
            const size = W * H;

            // 1. Macroscopic quantities
            for (let i = 0; i < size; i++) {
                let r = 0, vx = 0, vy = 0;
                for (let k = 0; k < 9; k++) {
                    const fk = f[i * 9 + k];
                    r += fk;
                    vx += fk * cx[k];
                    vy += fk * cy[k];
                }
                rho[i] = r;
                ux[i] = r > 0.001 ? vx / r : 0;
                uy[i] = r > 0.001 ? vy / r : 0;
                psi[i] = computePsi(r);
            }

            // 2. Forces (Shan-Chen + Buoyancy)
            const Fx = new Float32Array(size);
            const Fy = new Float32Array(size);

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const psi_i = psi[i];

                    let fx = 0, fy = 0;
                    for (let k = 1; k < 9; k++) {
                        let nx = x + cx[k];
                        let ny = y + cy[k];
                        nx = (nx + W) % W;
                        if (ny < 0) ny = 0;
                        if (ny >= H) ny = H - 1;
                        const ni = ny * W + nx;

                        fx += w[k] * psi[ni] * cx[k];
                        fy += w[k] * psi[ni] * cy[k];
                    }

                    Fx[i] = -G_INTERACTION * psi_i * fx;
                    Fy[i] = -G_INTERACTION * psi_i * fy;

                    const r = rho[i];
                    // Only apply buoyancy to "heavy" fluid (wax)
                    if (r > 0.5) {
                        const t = temp[i];
                        // Thermal buoyancy: proportional to temperature
                        const lift = -THERMAL_BUOYANCY * r * (t - NEUTRAL_TEMP);
                        const gravity = BASE_GRAVITY * r;
                        Fy[i] += lift + gravity;
                    }
                }
            }

            // 3. Collision
            for (let i = 0; i < size; i++) {
                const r = rho[i];
                if (r < 0.001) continue;

                const vx = ux[i] + Fx[i] / r * 0.5;
                const vy = uy[i] + Fy[i] / r * 0.5;
                // Limit velocity to prevent NaN explosions
                const MAX_VEL = 0.15; // Strict speed limit
                const vx_clamped = Math.max(-MAX_VEL, Math.min(MAX_VEL, vx));
                const vy_clamped = Math.max(-MAX_VEL, Math.min(MAX_VEL, vy));

                const usq = vx_clamped * vx_clamped + vy_clamped * vy_clamped;

                for (let k = 0; k < 9; k++) {
                    const cu = cx[k] * vx_clamped + cy[k] * vy_clamped;
                    const feq = w[k] * r * (1 + 3 * cu + 4.5 * cu * cu - 1.5 * usq);
                    const forceTerm = w[k] * (1 - 0.5 / TAU) * (
                        3 * (cx[k] - vx_clamped) + 9 * cu * cx[k]
                    ) * Fx[i] + w[k] * (1 - 0.5 / TAU) * (
                        3 * (cy[k] - vy_clamped) + 9 * cu * cy[k]
                    ) * Fy[i];

                    f[i * 9 + k] += -(f[i * 9 + k] - feq) / TAU + forceTerm;
                }
            }

            // 4. Streaming
            for (let i = 0; i < size * 9; i++) fTemp[i] = 0;

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    for (let k = 0; k < 9; k++) {
                        let nx = x + cx[k];
                        let ny = y + cy[k];
                        nx = (nx + W) % W;

                        if (ny < 0 || ny >= H) {
                            fTemp[i * 9 + opposite[k]] += f[i * 9 + k];
                        } else {
                            const ni = ny * W + nx;
                            fTemp[ni * 9 + k] += f[i * 9 + k];
                        }
                    }
                }
            }
            [f, fTemp] = [fTemp, f];

            // 5. Temperature (with stricter insulation)
            const newTemp = new Float32Array(size);
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    let t = temp[i];

                    // Diffusion: Split into internal (wax-wax) and leak (wax-water)
                    let sum = 0, count = 0;
                    const myRho = rho[i];
                    const isWax = myRho > 0.5;

                    for (const [dx, dy] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                        const nx = (x + dx + W) % W;
                        const ny = y + dy;
                        if (ny >= 0 && ny < H) {
                            const ni = ny * W + nx;
                            const nRho = rho[ni];
                            const neighborIsWax = nRho > 0.5;

                            // Logic:
                            // Wax-Wax: High diffusion (equilibrate fast)
                            // Water-Water: Low diffusion (don't care)
                            // Wax-Water: LEAK diffusion (very low)

                            let weight = TEMP_DIFFUSION_LEAK;
                            if (isWax && neighborIsWax) weight = TEMP_DIFFUSION_WAX;

                            sum += temp[ni] * weight;
                            count += weight;
                        }
                    }
                    if (count > 0) {
                        t += (sum / count - t); // Simple relaxation to weighted average
                    }

                    // Heating (Bottom)
                    const bottomZone = H * 0.90; // Lower heater
                    if (y > bottomZone && rho[i] > 0.5) {
                        const intensity = (y - bottomZone) / (H - bottomZone);
                        // Sharp Gaussian heater to force central plume
                        const dx = (x - W / 2) / (W / HEATER_WIDTH_FRACTION);
                        const heating = Math.exp(-dx * dx) * intensity;
                        t += HEAT_RATE * heating;
                    }

                    // Cooling (Top)
                    const topZone = H * 0.25; // Top 25% (Upper fourth)
                    if (y < topZone) {
                        const intensity = (topZone - y) / topZone;
                        t -= COOL_RATE * intensity;
                    }

                    newTemp[i] = Math.max(0, Math.min(1, t));
                }
            }
            temp = newTemp;
        }

        function render() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imageData = ctx.createImageData(W, H);
            const data = imageData.data;

            for (let i = 0; i < W * H; i++) {
                const d = rho[i];
                const t = temp[i];
                const pi = i * 4;

                if (d > 0.5) {
                    // Wax
                    // Color ramp from Cold (Red/Dark) to Hot (Orange/Bright)
                    let r, g, b;
                    const heat = Math.min(1, Math.max(0, (t - 0.2) / 0.8));

                    r = 180 + 75 * heat;
                    g = 20 + 200 * heat;
                    b = 40 + 60 * heat;

                    data[pi] = r;
                    data[pi + 1] = g;
                    data[pi + 2] = b;
                    data[pi + 3] = 255;
                } else {
                    // Background
                    // Viz temp slightly in background to see heat flow
                    data[pi] = 10 + t * 20;
                    data[pi + 1] = 10 + t * 10;
                    data[pi + 2] = 20;
                    data[pi + 3] = 255;
                }
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = W;
            tempCanvas.height = H;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.scale(CELL, CELL);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();

            // UI Overlays
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            ctx.fillRect(W / 2 * CELL - 50, H * CELL - 5, 100, 5); // Heater
        }

        function loop() {
            if (!paused) {
                for (let i = 0; i < ff; i++) tick();
            }
            render();

            const mass = getTotalMass();
            document.getElementById('stats').innerHTML =
                `Frames: ${frame}<br>Mass: ${mass.toFixed(0)}<br>Grid: ${W}x${H}`;

            requestAnimationFrame(loop);
        }

        document.getElementById('ff').onclick = () => {
            ff = ff === 1 ? 10 : ff === 10 ? 100 : 1;
            document.getElementById('ff').textContent = ff + 'x';
        };
        document.getElementById('pp').onclick = () => {
            paused = !paused;
            document.getElementById('pp').textContent = paused ? 'â–¶' : '||';
        };
        document.getElementById('rr').onclick = reset;
        addEventListener('resize', resize);

        resize();
        loop();
    </script>
</body>

</html>