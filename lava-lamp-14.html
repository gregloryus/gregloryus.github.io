<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp v14</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font: 11px monospace; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 4px; }
        #controls { position: absolute; top: 10px; right: 10px; }
        #controls button { padding: 8px 14px; margin: 2px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 12px monospace; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div>Lava Lamp v14</div>
    <div id="stats"></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="rr">Reset</button>
</div>
<script>
// v14: Updated heating/cooling zones
// Heating: full width, bottom 10 rows with gradient (100% at bottom, 10% at row 10)
// Cooling: mild 5% above halfway, gradient in top 10 rows (100% at top, 10% at row 10)

const CELL = 3;
const GRAVITY = 0.5;
const BUOYANCY = 0.9;
const HEAT_IN = 0.005;
const HEAT_DIFF = 0.05;
const COOL = 0.01;
const SURFACE_TENSION = 0.1;
const FLOW_RATE = 0.7;

// Zone sizes
const HEAT_ZONE_ROWS = 10;      // Bottom rows that apply heat
const COOL_ZONE_ROWS = 10;      // Top rows that apply strong cooling
const MILD_COOL_INTENSITY = 0.01; // Cooling intensity above halfway

// Initial wax setup
const WAX_HEIGHT_FRAC = 0.1;    // Fraction of canvas height for initial wax
const WAX_GAP_WIDTH = 10;       // Width of gap in center of initial wax

let W, H, grid, frame = 0, paused = false, ff = 1;
let initialMass;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = Math.floor(canvas.width / CELL);
    H = Math.floor(canvas.height / CELL);
    reset();
}

function reset() {
    grid = new Float32Array(W * H * 2);
    const wH = Math.floor(H * WAX_HEIGHT_FRAC);
    const centerX = Math.floor(W / 2);
    const gapLeft = centerX - Math.floor(WAX_GAP_WIDTH / 2);
    const gapRight = centerX + Math.ceil(WAX_GAP_WIDTH / 2);
    for (let y = H - wH; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= gapLeft && x < gapRight) continue; // gap in center
            grid[(y * W + x) * 2] = 1;
            grid[(y * W + x) * 2 + 1] = 0.1;
        }
    }
    initialMass = getMass();
    frame = 0;
}

function getMass() {
    let m = 0;
    for (let i = 0; i < W * H; i++) m += grid[i * 2];
    return m;
}

function D(x, y) { return (x >= 0 && x < W && y >= 0 && y < H) ? grid[(y * W + x) * 2] : 0; }
function T(x, y) { return (x >= 0 && x < W && y >= 0 && y < H) ? grid[(y * W + x) * 2 + 1] : 0; }

function tick() {
    frame++;
    const next = new Float32Array(W * H * 2);
    for (let i = 0; i < next.length; i++) next[i] = grid[i];

    // Heat sources and sinks
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            if (next[i] < 0.01) continue;

            // HEATING: entire x-axis, bottom HEAT_ZONE_ROWS rows
            const rowsFromBottom = H - 1 - y;
            if (rowsFromBottom < HEAT_ZONE_ROWS) {
                const heatIntensity = (HEAT_ZONE_ROWS - rowsFromBottom) / HEAT_ZONE_ROWS;
                next[i + 1] = Math.min(1, next[i + 1] + HEAT_IN * heatIntensity);
            }

            // COOLING: mild cooling above halfway, gradient in top COOL_ZONE_ROWS rows
            const halfwayY = Math.floor(H / 2);
            if (y < halfwayY) {
                let coolIntensity = MILD_COOL_INTENSITY;

                // Top COOL_ZONE_ROWS get gradient cooling
                if (y < COOL_ZONE_ROWS) {
                    coolIntensity = (COOL_ZONE_ROWS - y) / COOL_ZONE_ROWS;
                }

                next[i + 1] = Math.max(0, next[i + 1] - COOL * coolIntensity);
            }
        }
    }

    // Heat diffusion
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = (y * W + x) * 2;
            const d = next[i];
            if (d < 0.01) continue;
            let sum = next[i + 1] * d, wt = d;
            for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const nd = D(x+dx, y+dy);
                if (nd > 0.01) { sum += T(x+dx, y+dy) * nd; wt += nd; }
            }
            next[i + 1] += ((sum / wt) - next[i + 1]) * HEAT_DIFF;
        }
    }

    // Calculate all transfers (mass-conserving)
    const transfers = [];

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const d = next[(y * W + x) * 2];
            if (d < 0.02) continue;
            const t = next[(y * W + x) * 2 + 1];

            // === GRAVITY + BUOYANCY ===
            const netForce = t * BUOYANCY - GRAVITY;
            const dy = netForce > 0 ? -1 : 1;
            const ty = y + dy;

            if (ty >= 0 && ty < H) {
                const targetD = next[(ty * W + x) * 2];
                const space = 1 - targetD;
                if (space > 0.01) {
                    const amount = Math.min(Math.abs(netForce) * FLOW_RATE, d * 0.4, space);
                    if (amount > 0.005) {
                        transfers.push({fx: x, fy: y, tx: x, ty: ty, amount, temp: t});
                    }
                }
            }

            // === SURFACE TENSION ===
            let neighborD = 0;
            let bestDir = null, bestScore = 0;

            for (const [dx, ddy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const nx = x + dx, ny = y + ddy;
                const nd = (nx >= 0 && nx < W && ny >= 0 && ny < H) ? next[(ny * W + nx) * 2] : 0;
                neighborD += nd;

                if (nd < d - 0.1) {
                    let score = 0;
                    for (const [ddx, ddy2] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                        const nnx = nx + ddx, nny = ny + ddy2;
                        if (nnx >= 0 && nnx < W && nny >= 0 && nny < H) {
                            score += next[(nny * W + nnx) * 2];
                        }
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestDir = [dx, ddy];
                    }
                }
            }

            if (neighborD < 3 && bestDir && d > 0.2) {
                const [sdx, sdy] = bestDir;
                const stx = x + sdx, sty = y + sdy;
                if (stx >= 0 && stx < W && sty >= 0 && sty < H) {
                    const targetD = next[(sty * W + stx) * 2];
                    const space = 1 - targetD;
                    const exposure = (4 - neighborD) / 4;
                    const amount = Math.min(SURFACE_TENSION * exposure * d, space, d * 0.3);
                    if (amount > 0.005) {
                        transfers.push({fx: x, fy: y, tx: stx, ty: sty, amount, temp: t});
                    }
                }
            }
        }
    }

    // Apply all transfers (mass-conserving)
    for (const tr of transfers) {
        const fi = (tr.fy * W + tr.fx) * 2;
        const ti = (tr.ty * W + tr.tx) * 2;

        const fromD = next[fi];
        const toD = next[ti];

        const actualAmount = Math.min(tr.amount, fromD - 0.01, 1 - toD);
        if (actualAmount < 0.005) continue;

        next[fi] -= actualAmount;
        next[ti] += actualAmount;

        const newToD = next[ti];
        if (newToD > 0.01) {
            const oldToD = toD;
            const oldToT = next[ti + 1];
            next[ti + 1] = (oldToT * oldToD + tr.temp * actualAmount) / newToD;
        }
    }

    // === BLOB ROUNDING ===
    for (let y = 1; y < H - 1; y++) {
        for (let x = 1; x < W - 1; x++) {
            const i = (y * W + x) * 2;
            const d = next[i];
            if (d < 0.3) continue;

            const up = next[((y-1) * W + x) * 2];
            const dn = next[((y+1) * W + x) * 2];
            const lt = next[(y * W + x - 1) * 2];
            const rt = next[(y * W + x + 1) * 2];

            if (up > 0.5 && dn > 0.5 && lt < 0.2 && rt < 0.2) {
                const spread = d * 0.05;
                if (spread > 0.01) {
                    next[i] -= spread * 2;
                    next[(y * W + x - 1) * 2] += spread;
                    next[(y * W + x + 1) * 2] += spread;
                }
            }

            if (lt > 0.5 && rt > 0.5 && up < 0.2 && dn < 0.2) {
                const spread = d * 0.05;
                if (spread > 0.01) {
                    next[i] -= spread * 2;
                    next[((y-1) * W + x) * 2] += spread;
                    next[((y+1) * W + x) * 2] += spread;
                }
            }

            const total = (up > 0.3 ? 1 : 0) + (dn > 0.3 ? 1 : 0) + (lt > 0.3 ? 1 : 0) + (rt > 0.3 ? 1 : 0);
            if (total === 1 && d > 0.3) {
                const pull = d * 0.15;
                next[i] -= pull;
                if (up > 0.3) next[((y-1) * W + x) * 2] += pull;
                else if (dn > 0.3) next[((y+1) * W + x) * 2] += pull;
                else if (lt > 0.3) next[(y * W + x - 1) * 2] += pull;
                else if (rt > 0.3) next[(y * W + x + 1) * 2] += pull;
            }
        }
    }

    // Clamp values
    for (let i = 0; i < W * H; i++) {
        next[i * 2] = Math.max(0, Math.min(1, next[i * 2]));
        next[i * 2 + 1] = Math.max(0, Math.min(1, next[i * 2 + 1]));
    }

    grid = next;
}

function render() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const d = grid[(y * W + x) * 2];
            if (d < 0.05) continue;
            const t = grid[(y * W + x) * 2 + 1];

            let r, g, b;
            if (t < 0.35) {
                r = 50 + 120 * (t / 0.35);
                g = 20 + 40 * (t / 0.35);
                b = 80 - 40 * (t / 0.35);
            } else if (t < 0.65) {
                const f = (t - 0.35) / 0.3;
                r = 170 + 60 * f;
                g = 60 + 80 * f;
                b = 40 - 20 * f;
            } else {
                const f = (t - 0.65) / 0.35;
                r = 230 + 25 * f;
                g = 140 + 115 * f;
                b = 20 + 100 * f;
            }

            ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${0.5 + d * 0.5})`;
            ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }
    }

    // Heater indicator (full width)
    ctx.fillStyle = 'rgba(255,80,0,0.6)';
    ctx.fillRect(0, (H-1) * CELL, W * CELL, 2);
}

function loop() {
    if (!paused) for (let i = 0; i < ff; i++) tick();
    render();

    const mass = getMass();
    document.getElementById('stats').innerHTML =
        `Tick: ${frame} | Mass: ${mass.toFixed(0)}/${initialMass.toFixed(0)} | FPS: 60`;

    requestAnimationFrame(loop);
}

document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 5 : ff === 5 ? 25 : ff === 25 ? 100 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? 'â–¶' : '||';
};
document.getElementById('rr').onclick = reset;
addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyR') reset();
});

resize();
loop();
</script>
</body>
</html>
