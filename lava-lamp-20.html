<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp v20</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; background: #0a0a12; }
        #canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; color: #fff; font: 11px monospace; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 4px; }
        #controls { position: absolute; top: 10px; right: 10px; }
        #controls button { padding: 8px 14px; margin: 2px; background: #222; color: #fff; border: 1px solid #555; cursor: pointer; font: 12px monospace; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
    <div>Lava Lamp v20</div>
    <div id="stats"></div>
</div>
<div id="controls">
    <button id="ff">1x</button>
    <button id="pp">||</button>
    <button id="rr">Reset</button>
</div>
<script>
// v20: DISCRETE DENSITIES ONLY
// Cells can only be: 0, 0.5, or 1.0
//
// Rules:
// 1. HEAT/COOL: Temperature changes continuously (0-1)
// 2. EXPAND: Hot 1.0 cell splits into two 0.5 cells
// 3. CONTRACT: Two cold 0.5 neighbors merge into one 1.0 cell
// 4. RISE: Hot 0.5 cell moves up into empty space
// 5. SINK: Cold 0.5 cell moves down into empty space
// 6. DIFFUSE: Temperature spreads between touching wax

const CELL = 3;

// Thresholds
const MELT_TEMP = 0.5;      // Above this, 1.0 can split
const FREEZE_TEMP = 0.3;    // Below this, 0.5 can merge
const RISE_TEMP = 0.6;      // Above this, wax rises
const SINK_TEMP = 0.25;     // Below this, wax sinks

// Rates (probabilities per tick)
const EXPAND_CHANCE = 0.1;
const CONTRACT_CHANCE = 0.15;
const MOVE_CHANCE = 0.3;

// Heat
const HEAT_IN = 0.015;
const HEAT_DIFF = 0.05;
const COOL = 0.02;
const INTENSITY_POWER = 2;

// Initial setup
const WAX_HEIGHT_FRAC = 0.1;

let W, H, grid, frame = 0, paused = false, ff = 1;
let initialMass;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    W = Math.floor(canvas.width / CELL);
    H = Math.floor(canvas.height / CELL);
    reset();
}

function reset() {
    grid = new Float32Array(W * H * 2);
    const wH = Math.floor(H * WAX_HEIGHT_FRAC);
    for (let y = H - wH; y < H; y++) {
        for (let x = 0; x < W; x++) {
            grid[(y * W + x) * 2] = 1.0;  // Full density
            grid[(y * W + x) * 2 + 1] = 0.1;  // Cold
        }
    }
    initialMass = getMass();
    frame = 0;
}

function getMass() {
    let m = 0;
    for (let i = 0; i < W * H; i++) m += grid[i * 2];
    return m;
}

function wrapX(x) { return ((x % W) + W) % W; }
function idx(x, y) { return (y * W + wrapX(x)) * 2; }
function D(x, y) { return (y >= 0 && y < H) ? grid[idx(x, y)] : -1; }
function T(x, y) { return (y >= 0 && y < H) ? grid[idx(x, y) + 1] : 0; }

function tick() {
    frame++;
    const next = new Float32Array(W * H * 2);
    for (let i = 0; i < next.length; i++) next[i] = grid[i];

    // === HEATING/COOLING ===
    const bottomThird = Math.floor(H * 2 / 3);
    const topThird = Math.floor(H / 3);
    const centerX = W / 2;

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = idx(x, y);
            if (next[i] < 0.1) continue;

            // Bottom heats (centralized)
            if (y >= bottomThird) {
                const vertI = Math.pow((y - bottomThird) / (H - bottomThird), INTENSITY_POWER);
                const horizI = Math.pow(1 - Math.abs(x - centerX) / centerX, INTENSITY_POWER);
                next[i + 1] = Math.min(1, next[i + 1] + HEAT_IN * vertI * horizI);
            }

            // Top cools
            if (y < topThird) {
                const intensity = Math.pow(1 - y / topThird, INTENSITY_POWER);
                next[i + 1] = Math.max(0, next[i + 1] - COOL * intensity);
            }
        }
    }

    // === HEAT DIFFUSION ===
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const i = idx(x, y);
            const d = next[i];
            if (d < 0.1) continue;

            let sum = next[i + 1] * d, wt = d;
            for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
                const nd = D(x+dx, y+dy);
                if (nd > 0.1) {
                    sum += T(x+dx, y+dy) * nd;
                    wt += nd;
                }
            }
            next[i + 1] += ((sum / wt) - next[i + 1]) * HEAT_DIFF;
        }
    }

    // === EXPANSION: Hot 1.0 → two 0.5 ===
    // Process in random order to avoid bias
    const cells = [];
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            cells.push([x, y]);
        }
    }
    shuffle(cells);

    for (const [x, y] of cells) {
        const i = idx(x, y);
        const d = next[i];
        const t = next[i + 1];

        // Only full cells can expand
        if (d < 0.9 || t < MELT_TEMP) continue;
        if (Math.random() > EXPAND_CHANCE) continue;

        // Find empty neighbor (prefer up for hot wax)
        const dirs = [[0,-1],[-1,0],[1,0],[0,1]];
        for (const [dx, dy] of dirs) {
            const ny = y + dy;
            if (ny < 0 || ny >= H) continue;
            const ni = idx(x + dx, ny);
            if (next[ni] < 0.1) {
                // Split: this becomes 0.5, neighbor becomes 0.5
                next[i] = 0.5;
                next[ni] = 0.5;
                next[ni + 1] = t;  // Same temperature
                break;
            }
        }
    }

    // === CONTRACTION: Two cold 0.5 → one 1.0 ===
    shuffle(cells);
    for (const [x, y] of cells) {
        const i = idx(x, y);
        const d = next[i];
        const t = next[i + 1];

        // Only half cells can merge
        if (d < 0.4 || d > 0.6 || t > FREEZE_TEMP) continue;
        if (Math.random() > CONTRACT_CHANCE) continue;

        // Find a 0.5 neighbor to merge with (prefer down for cold wax)
        const dirs = [[0,1],[1,0],[-1,0],[0,-1]];
        for (const [dx, dy] of dirs) {
            const ny = y + dy;
            if (ny < 0 || ny >= H) continue;
            const ni = idx(x + dx, ny);
            const nd = next[ni];
            const nt = next[ni + 1];

            if (nd >= 0.4 && nd <= 0.6 && nt < FREEZE_TEMP) {
                // Merge: this becomes 1.0, neighbor becomes 0
                next[i] = 1.0;
                next[i + 1] = (t + nt) / 2;
                next[ni] = 0;
                next[ni + 1] = 0;
                break;
            }
        }
    }

    // === MOVEMENT: 0.5 cells rise or sink ===
    shuffle(cells);
    for (const [x, y] of cells) {
        const i = idx(x, y);
        const d = next[i];
        const t = next[i + 1];

        // Only half cells move freely
        if (d < 0.4 || d > 0.6) continue;

        let targetY = -1;
        if (t > RISE_TEMP && y > 0) {
            targetY = y - 1;  // Rise
        } else if (t < SINK_TEMP && y < H - 1) {
            targetY = y + 1;  // Sink
        }

        if (targetY >= 0) {
            const ti = idx(x, targetY);
            if (next[ti] < 0.1 && Math.random() < MOVE_CHANCE) {
                // Move: swap with empty
                next[ti] = d;
                next[ti + 1] = t;
                next[i] = 0;
                next[i + 1] = 0;
            }
        }
    }

    // === LATERAL SPREAD: Prevent tall stacks ===
    // 0.5 cells with vertical neighbors but no horizontal neighbors spread sideways
    shuffle(cells);
    for (const [x, y] of cells) {
        const i = idx(x, y);
        const d = next[i];
        if (d < 0.4) continue;

        const up = D(x, y-1);
        const dn = D(x, y+1);
        const lt = D(x-1, y);
        const rt = D(x+1, y);

        // If we have vertical neighbors but horizontal is empty
        if ((up > 0.3 || dn > 0.3) && lt < 0.1 && rt < 0.1) {
            // Try to spread sideways (with low probability)
            if (Math.random() < 0.05) {
                const dir = Math.random() < 0.5 ? -1 : 1;
                const ni = idx(x + dir, y);
                if (next[ni] < 0.1 && d > 0.9) {
                    // Split sideways
                    next[i] = 0.5;
                    next[ni] = 0.5;
                    next[ni + 1] = next[i + 1];
                }
            }
        }
    }

    grid = next;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function render() {
    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const d = grid[idx(x, y)];
            if (d < 0.1) continue;
            const t = grid[idx(x, y) + 1];

            let r, g, b;
            if (t < 0.35) {
                r = 50 + 120 * (t / 0.35);
                g = 20 + 40 * (t / 0.35);
                b = 80 - 40 * (t / 0.35);
            } else if (t < 0.65) {
                const f = (t - 0.35) / 0.3;
                r = 170 + 60 * f;
                g = 60 + 80 * f;
                b = 40 - 20 * f;
            } else {
                const f = (t - 0.65) / 0.35;
                r = 230 + 25 * f;
                g = 140 + 115 * f;
                b = 20 + 100 * f;
            }

            // Show density difference: 0.5 slightly transparent
            const alpha = d > 0.7 ? 1.0 : 0.7;
            ctx.fillStyle = `rgba(${r|0},${g|0},${b|0},${alpha})`;
            ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
        }
    }

    ctx.fillStyle = 'rgba(255,80,0,0.6)';
    ctx.fillRect(0, (H-1) * CELL, W * CELL, 2);
}

function loop() {
    if (!paused) for (let i = 0; i < ff; i++) tick();
    render();

    const mass = getMass();
    document.getElementById('stats').innerHTML =
        `Tick: ${frame} | Mass: ${mass.toFixed(1)}/${initialMass.toFixed(1)}`;

    requestAnimationFrame(loop);
}

document.getElementById('ff').onclick = () => {
    ff = ff === 1 ? 5 : ff === 5 ? 25 : ff === 25 ? 100 : 1;
    document.getElementById('ff').textContent = ff + 'x';
};
document.getElementById('pp').onclick = () => {
    paused = !paused;
    document.getElementById('pp').textContent = paused ? '▶' : '||';
};
document.getElementById('rr').onclick = reset;
addEventListener('resize', resize);
addEventListener('keydown', e => {
    if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    if (e.code === 'KeyR') reset();
});

resize();
loop();
</script>
</body>
</html>
